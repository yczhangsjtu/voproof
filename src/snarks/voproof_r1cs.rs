///! This file is generated by scripts/main.py
use super::*;








pub struct R1CSProverKey<'a, E: PairingEngine> {
    pub verifier_key: R1CSVerifierKey<E>,
    pub powers: Powers<'a, E>,
    pub max_degree: u64,
    pub u_vec: Vec<E::Fr>,
    pub w_vec: Vec<E::Fr>,
    pub v_vec: Vec<E::Fr>,
    pub y_vec: Vec<E::Fr>,
}

pub struct R1CSVerifierKey<E: PairingEngine> {
    pub cm_u_vec: Commitment<E>,
    pub cm_w_vec: Commitment<E>,
    pub cm_v_vec: Commitment<E>,
    pub cm_y_vec: Commitment<E>,
    pub kzg_vk: VerifierKey<E>,
    pub size: R1CSSize,
}

pub struct R1CSProof<E: PairingEngine> {
    pub cm_u_vec_1: Commitment<E>,
    pub cm_s_vec: Commitment<E>,
    pub cm_h_vec: Commitment<E>,
    pub cm_r_vec_tilde: Commitment<E>,
    pub cm_t: Commitment<E>,
    pub cm_h_1: Commitment<E>,
    pub cm_h_2: Commitment<E>,
    pub y: E::Fr,
    pub y_1: E::Fr,
    pub y_2: E::Fr,
    pub W: KZGProof<E>,
    pub W_1: KZGProof<E>,
}

pub struct VOProofR1CS {}

impl<'a, E: PairingEngine> SNARKProverKey<E> for R1CSProverKey<'a, E> {}

impl<E: PairingEngine> SNARKVerifierKey<E> for R1CSVerifierKey<E> {}

impl<E: PairingEngine> SNARKProof<E> for R1CSProof<E> {}

impl VOProofR1CS {
    fn get_max_degree(size: &R1CSSize) -> usize {
        let H=size.nrows;
        let K=size.ncols;
        let S=size.density;
        
        K + 6*S
    }
}

impl<'a, E: PairingEngine, F: Field> SNARK<E, F> for VOProofR1CS {
    type Size = R1CSSize;
    type CS = R1CS<E::Fr>;
    type PK = R1CSProverKey<'a, E>;
    type VK = R1CSVerifierKey<E>;
    type Ins = R1CSInstance<E::Fr>;
    type Wit = R1CSWitness<E::Fr>;
    type Pf = R1CSProof<E>;

    fn setup(size: usize) -> UniversalParams<E> {
        KZG10::<E, DensePoly<E::Fr>>::setup(size)
    }

    fn index(pp: &UniversalParams<E>, cs: &R1CS<F>)
        -> Result<(R1CSProverKey<'a, E>, R1CSVerifierKey<E>), Error> {
        let max_degree = Self::get_max_degree(cs.get_size());
        assert!(pp.powers_of_g.len() > max_degree);

        let mut powers_of_g = Vec::new();
        // The prover needs both the lowest `max_degree` powers of g,
        // and the highest `max_degree` powers of g, to make sure that
        // some polynomials are bounded by particular degree bounds
        // To save space, store all the needed powers of g in the same
        // vector, because the lower part and the higher part may share
        // common powers of g.
        if pp.powers_of_g.len() >= 2 * (max_degree + 1) {
            powers_of_g = pp.powers_of_g[..=max_degree].to_vec();
            powers_of_g.append(pp.powers_of_g[pp.powers_of_g.len()-max_degree-1..]);
        } else {
            powers_of_g = pp.powers_of_g[..].to_vec();
        }
        let size = cs.get_size();
        let H=size.nrows;
        let K=size.ncols;
        let S=size.density;
        let H=size.nrows;
        let K=size.ncols;
        let S=size.density;
        
        let verifier_key = R1CSVerifierKey::<E> {
            cm_u_vec: cm_u_vec,
            cm_w_vec: cm_w_vec,
            cm_v_vec: cm_v_vec,
            cm_y_vec: cm_y_vec,
            kzg_vk: VerifierKey {
                g: pp.powers_of_g[0],
                h: pp.h,
                beta_h: pp.beta_h,
                prepared_h: pp.prepared_h.clone(),
                prepared_beta_h: pp.prepared_beta_h.clone(),
            },
            size,
        };
        Ok((R1CSProverKey::<E> {
            verifier_key,
            powers: powers_of_g,
            max_degree,
            u_vec: u_vec,
            w_vec: w_vec,
            v_vec: v_vec,
            y_vec: y_vec,
        }, verifier_key))
    }
    fn prove(pk: &Self::PK, x: &Self::Ins, w: &Self::Wit) -> Result<Self::Pf, Error> {
        let size = pk.verifier_key.size;
        let rng = &mut test_rng();
        let H=size.nrows;
        let K=size.ncols;
        let S=size.density;
        let delta=sample_field::<F, _>(rng);
        let delta_1=sample_field::<F, _>(rng);
        let delta_2=sample_field::<F, _>(rng);
        let delta_3=sample_field::<F, _>(rng);
        let u_vec_1=sparse_mvp(H, K);
        let r_vec_tilde=(1..=K + 3*S).scan(F::zero(), |acc, &mut i| {*acc = *acc + (r_vec_1[i - 1]); Some(*acc)}).collect::<Vec<F>>();
        
        Ok(R1CSProof::<E> {
            cm_u_vec_1: cm_u_vec_1,
            cm_s_vec: cm_s_vec,
            cm_h_vec: cm_h_vec,
            cm_r_vec_tilde: cm_r_vec_tilde,
            cm_t: cm_t,
            cm_h_1: cm_h_1,
            cm_h_2: cm_h_2,
            y: y,
            y_1: y_1,
            y_2: y_2,
            W: W,
            W_1: W_1,
        })
    }
    fn verify(vk: &Self::VK, x: &Self::Ins, proof: &Self::Pf) -> Result<(), Error> {
        let size = vk.size;
        let H=size.nrows;
        let K=size.ncols;
        let S=size.density;
        
    }
}



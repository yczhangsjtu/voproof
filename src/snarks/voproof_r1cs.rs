///! This file is generated by scripts/main.py
use super::*;

#[derive(Clone)]
pub struct R1CSProverKey<E: PairingEngine> {
    pub verifier_key: R1CSVerifierKey<E>,
    pub powers: Vec<E::G1Affine>,
    pub max_degree: u64,
    pub M_mat: (Vec<u64>, Vec<u64>, Vec<E::Fr>),
    pub u_vec: Vec<E::Fr>,
    pub w_vec: Vec<E::Fr>,
    pub v_vec: Vec<E::Fr>,
    pub y_vec: Vec<E::Fr>,
}

#[derive(Clone)]
pub struct R1CSVerifierKey<E: PairingEngine> {
    pub cm_u_vec: Commitment<E>,
    pub cm_w_vec: Commitment<E>,
    pub cm_v_vec: Commitment<E>,
    pub cm_y_vec: Commitment<E>,
    pub kzg_vk: VerifierKey<E>,
    pub size: R1CSSize,
    pub D: u64,
}

#[derive(Clone)]
pub struct R1CSProof<E: PairingEngine> {
    pub cm_u_vec_1: Commitment<E>,
    pub cm_s_vec: Commitment<E>,
    pub cm_h_vec: Commitment<E>,
    pub cm_r_vec_tilde: Commitment<E>,
    pub cm_t_vec_1: Commitment<E>,
    pub cm_h_vec_2: Commitment<E>,
    pub cm_h_vec_3: Commitment<E>,
    pub y: E::Fr,
    pub y_1: E::Fr,
    pub y_2: E::Fr,
    pub W: KZGProof<E>,
    pub W_1: KZGProof<E>,
}

pub struct VOProofR1CS {}

impl<E: PairingEngine> SNARKProverKey<E> for R1CSProverKey<E> {}

impl<E: PairingEngine> SNARKVerifierKey<E> for R1CSVerifierKey<E> {}

impl<E: PairingEngine> SNARKProof<E> for R1CSProof<E> {}

impl VOProofR1CS {
    pub fn get_max_degree(size: R1CSSize) -> usize {
        let H = size.nrows as i64;
        let K = size.ncols as i64;
        let S_a = size.adensity as i64;
        let S_b = size.bdensity as i64;
        let S_c = size.cdensity as i64;
        let ell = size.input_size as i64;

        (K + 2 * S_a + 2 * S_b + 2 * S_c) as usize
    }
}

impl<E: PairingEngine> SNARK<E> for VOProofR1CS {
    type Size = R1CSSize;
    type CS = R1CS<E::Fr>;
    type PK = R1CSProverKey<E>;
    type VK = R1CSVerifierKey<E>;
    type Ins = R1CSInstance<E::Fr>;
    type Wit = R1CSWitness<E::Fr>;
    type Pf = R1CSProof<E>;

    fn setup(size: usize) -> Result<UniversalParams<E>, Error> {
        let rng = &mut test_rng();
        KZG10::<E, DensePoly<E::Fr>>::setup(size, rng)
    }

    fn index(
        pp: &UniversalParams<E>,
        cs: &R1CS<E::Fr>,
    ) -> Result<(R1CSProverKey<E>, R1CSVerifierKey<E>), Error> {
        let max_degree = Self::get_max_degree(cs.get_size());
        assert!(pp.powers_of_g.len() > max_degree);

        let mut powers_of_g = Vec::<E::G1Affine>::new();
        // The prover needs both the lowest `max_degree` powers of g,
        // and the highest `max_degree` powers of g, to make sure that
        // some polynomials are bounded by particular degree bounds
        // To save space, store all the needed powers of g in the same
        // vector, because the lower part and the higher part may share
        // common powers of g.
        if pp.powers_of_g.len() >= 2 * (max_degree + 1) {
            powers_of_g = pp.powers_of_g[..=max_degree].to_vec();
            powers_of_g
                .append(&mut pp.powers_of_g[pp.powers_of_g.len() - max_degree - 1..].to_vec());
        } else {
            powers_of_g = pp.powers_of_g[..].to_vec();
        }
        let size = cs.get_size();
        let H = size.nrows as i64;
        let K = size.ncols as i64;
        let S_a = size.adensity as i64;
        let S_b = size.bdensity as i64;
        let S_c = size.cdensity as i64;
        let ell = size.input_size as i64;
        let gamma = generator_of!(E);
        let M_mat = (
            cs.arows
                .iter()
                .map(|a| *a)
                .chain(cs.brows.iter().map(|&i| i + H as u64))
                .chain(cs.crows.iter().map(|&i| i + H as u64 * 2))
                .collect::<Vec<u64>>(),
            cs.acols
                .iter()
                .chain(cs.bcols.iter())
                .chain(cs.ccols.iter())
                .map(|a| *a)
                .collect::<Vec<u64>>(),
            cs.avals
                .iter()
                .chain(cs.bvals.iter())
                .chain(cs.cvals.iter())
                .map(|a| *a)
                .collect::<Vec<E::Fr>>(),
        );
        let u_vec = int_array_to_power_vector!(M_mat.0, gamma);
        let w_vec = int_array_to_power_vector!(M_mat.1, gamma);
        let v_vec = M_mat.2.to_vec();
        let y_vec = u_vec
            .iter()
            .zip(w_vec.iter())
            .map(|(a, b)| *a * *b)
            .collect::<Vec<E::Fr>>();
        println!(
            "vector u_vec of length {} = 
[{}]",
            u_vec.len(),
            fmt_ff_vector!(u_vec)
        );
        println!(
            "vector w_vec of length {} = 
[{}]",
            w_vec.len(),
            fmt_ff_vector!(w_vec)
        );
        println!(
            "vector v_vec of length {} = 
[{}]",
            v_vec.len(),
            fmt_ff_vector!(v_vec)
        );
        println!(
            "vector y_vec of length {} = 
[{}]",
            y_vec.len(),
            fmt_ff_vector!(y_vec)
        );
        let cm_u_vec = vector_to_commitment::<E>(&powers_of_g, &u_vec).unwrap();
        let cm_w_vec = vector_to_commitment::<E>(&powers_of_g, &w_vec).unwrap();
        let cm_v_vec = vector_to_commitment::<E>(&powers_of_g, &v_vec).unwrap();
        let cm_y_vec = vector_to_commitment::<E>(&powers_of_g, &y_vec).unwrap();

        let verifier_key = R1CSVerifierKey::<E> {
            cm_u_vec: cm_u_vec,
            cm_w_vec: cm_w_vec,
            cm_v_vec: cm_v_vec,
            cm_y_vec: cm_y_vec,
            kzg_vk: VerifierKey {
                g: pp.powers_of_g[0],
                h: pp.h,
                beta_h: pp.beta_h,
                prepared_h: pp.prepared_h.clone(),
                prepared_beta_h: pp.prepared_beta_h.clone(),
            },
            size,
            D: pp.powers_of_g.len() as u64,
        };
        Ok((
            R1CSProverKey::<E> {
                verifier_key: verifier_key.clone(),
                powers: powers_of_g,
                max_degree: max_degree as u64,
                M_mat: M_mat,
                u_vec: u_vec,
                w_vec: w_vec,
                v_vec: v_vec,
                y_vec: y_vec,
            },
            verifier_key,
        ))
    }
    fn prove(pk: &Self::PK, x: &Self::Ins, w: &Self::Wit) -> Result<Self::Pf, Error> {
        let size = pk.verifier_key.size.clone();
        let vk = pk.verifier_key.clone();
        let D = pk.verifier_key.D as i64;
        let rng = &mut test_rng();
        let H = size.nrows as i64;
        let K = size.ncols as i64;
        let S_a = size.adensity as i64;
        let S_b = size.bdensity as i64;
        let S_c = size.cdensity as i64;
        let ell = size.input_size as i64;
        let gamma = generator_of!(E);
        let x_vec = x.instance.clone();
        let delta_vec = sample_vec::<E::Fr, _>(rng, 1);
        let delta_vec_1 = sample_vec::<E::Fr, _>(rng, 1);
        let delta_vec_2 = sample_vec::<E::Fr, _>(rng, 1);
        let delta_vec_3 = sample_vec::<E::Fr, _>(rng, 1);
        let delta_vec_4 = sample_vec::<E::Fr, _>(rng, 1);
        let w_vec = w.witness.clone();
        let u_vec_1 = sparse_mvp(
            3 * H,
            K,
            &pk.M_mat.0,
            &pk.M_mat.1,
            &pk.M_mat.2,
            &vector_concat!(vec![E::Fr::one()], x_vec, w_vec),
        )
        .unwrap();
        let u_vec_1 = vector_concat!(u_vec_1, vec![E::Fr::one()], x_vec, w_vec);
        let u_vec_1 = zero_pad_and_concat!(u_vec_1, K + S_a + S_b + S_c, delta_vec);
        let cm_u_vec_1 = vector_to_commitment::<E>(&pk.powers, &u_vec_1).unwrap();
        let u_vec_1_poly = poly_from_vec!(u_vec_1);
        println!(
            "vector u_vec_1 of length {} = \n[{}]",
            u_vec_1.len(),
            fmt_ff_vector!(u_vec_1)
        );
        let mu = hash_to_field::<E::Fr>(
            to_bytes!(
                x_vec,
                pk.verifier_key.cm_u_vec,
                pk.verifier_key.cm_w_vec,
                pk.verifier_key.cm_v_vec,
                pk.verifier_key.cm_y_vec,
                cm_u_vec_1
            )
            .unwrap(),
        );
        let mut r_vec = expression_vector!(i, (mu) - (power_vector_index!(gamma, 3 * H, i)), 3 * H);
        batch_inversion(&mut r_vec);
        let c_vec = sparse_mvp(K, 3 * H, &pk.M_mat.1, &pk.M_mat.0, &pk.M_mat.2, &r_vec).unwrap();
        let s_vec = r_vec
            .iter()
            .map(|a| *a)
            .chain(c_vec.iter().map(|a| -*a))
            .collect::<Vec<E::Fr>>();
        let s_vec = zero_pad_and_concat!(s_vec, K + S_a + S_b + S_c, delta_vec_1);
        let cm_s_vec = vector_to_commitment::<E>(&pk.powers, &s_vec).unwrap();
        let s_vec_poly = poly_from_vec!(s_vec);
        println!(
            "vector s_vec of length {} = \n[{}]",
            s_vec.len(),
            fmt_ff_vector!(s_vec)
        );
        let nu = hash_to_field::<E::Fr>(
            to_bytes!(
                x_vec,
                pk.verifier_key.cm_u_vec,
                pk.verifier_key.cm_w_vec,
                pk.verifier_key.cm_v_vec,
                pk.verifier_key.cm_y_vec,
                cm_u_vec_1,
                cm_s_vec
            )
            .unwrap(),
        );
        let mut rnu_vec = expression_vector!(i, (nu) - (power_vector_index!(gamma, K, i)), K);
        batch_inversion(&mut rnu_vec);
        let h_vec = rnu_vec
            .iter()
            .map(|a| *a)
            .chain(
                pk.u_vec
                    .iter()
                    .map(|a| *a)
                    .zip(pk.w_vec.iter().map(|a| *a))
                    .map(|(u, w)| ((mu - u) * (nu - w)).inverse().unwrap()),
            )
            .collect::<Vec<E::Fr>>();
        let h_vec = zero_pad_and_concat!(h_vec, K + S_a + S_b + S_c, delta_vec_2);
        let cm_h_vec = vector_to_commitment::<E>(&pk.powers, &h_vec).unwrap();
        let h_vec_poly = poly_from_vec!(h_vec);
        println!(
            "vector h_vec of length {} = \n[{}]",
            h_vec.len(),
            fmt_ff_vector!(h_vec)
        );
        let beta = hash_to_field::<E::Fr>(
            to_bytes!(
                x_vec,
                pk.verifier_key.cm_u_vec,
                pk.verifier_key.cm_w_vec,
                pk.verifier_key.cm_v_vec,
                pk.verifier_key.cm_y_vec,
                cm_u_vec_1,
                cm_s_vec,
                cm_h_vec
            )
            .unwrap(),
        );
        define_vec!(
            r_vec_1,
            expression_vector!(
                i,
                power_linear_combination!(
                    beta,
                    (linear_combination!(
                        E::Fr::zero(),
                        to_field::<E::Fr>(1),
                        vector_index!(
                            u_vec_1,
                            (i as i64) - (-3 * H + S_a + S_b + S_c + 1) as i64 + 1
                        )
                    )) * (linear_combination!(
                        E::Fr::zero(),
                        to_field::<E::Fr>(1),
                        vector_index!(
                            s_vec,
                            (i as i64) - (-3 * H + S_a + S_b + S_c + 1) as i64 + 1
                        )
                    )),
                    ((linear_combination!(
                        E::Fr::zero(),
                        -to_field::<E::Fr>(1),
                        vector_index!(h_vec, (i as i64) - (S_a + S_b + S_c + 1) as i64 + 1)
                    )) * (linear_combination!(
                        E::Fr::zero(),
                        to_field::<E::Fr>(1),
                        vector_index!(
                            s_vec,
                            (i as i64) - (-3 * H + S_a + S_b + S_c + 1) as i64 + 1
                        )
                    ))) - ((linear_combination!(
                        E::Fr::zero(),
                        to_field::<E::Fr>(1),
                        vector_index!(h_vec, (i as i64) - (1) as i64 + 1)
                    )) * (linear_combination!(
                        E::Fr::zero(),
                        to_field::<E::Fr>(1),
                        vector_index!(pk.v_vec, (i as i64) - (K + 1) as i64 + 1)
                    )))
                ),
                K + S_a + S_b + S_c
            )
        );
        define_vec!(
            r_vec_tilde,
            vector_concat!(
                accumulate_vector!(
          r_vec_1,
          +),
                delta_vec_3
            )
        );
        let r_vec_tilde_poly = poly_from_vec!(r_vec_tilde);
        let cm_r_vec_tilde = vector_to_commitment::<E>(&pk.powers, &r_vec_tilde).unwrap();
        let alpha = hash_to_field::<E::Fr>(
            to_bytes!(
                x_vec,
                pk.verifier_key.cm_u_vec,
                pk.verifier_key.cm_w_vec,
                pk.verifier_key.cm_v_vec,
                pk.verifier_key.cm_y_vec,
                cm_u_vec_1,
                cm_s_vec,
                cm_h_vec,
                cm_r_vec_tilde
            )
            .unwrap(),
        );
        check_vector_eq!(
            expression_vector!(
                i,
                (linear_combination!(
                    E::Fr::zero(),
                    -to_field::<E::Fr>(1),
                    range_index!(1, 3 * H, i - (1) + 1)
                )) * (range_index!(1, 3 * H, i)),
                K + S_a + S_b + S_c
            ),
            expression_vector!(
                i,
                -(linear_combination!(
                    E::Fr::zero(),
                    mu,
                    range_index!(1, 3 * H, i - (1) + 1),
                    -to_field::<E::Fr>(1),
                    power_vector_index!(gamma, 3 * H, i - (1) + 1)
                )) * (vector_index!(s_vec, i)),
                K + S_a + S_b + S_c
            ),
            "The 1'th hadamard check is not satisfied"
        );
        check_vector_eq!(
            expression_vector!(
                i,
                (linear_combination!(
                    E::Fr::zero(),
                    -to_field::<E::Fr>(1),
                    range_index!(1, K, i - (1) + 1)
                )) * (range_index!(1, K, i)),
                K + S_a + S_b + S_c
            ),
            expression_vector!(
                i,
                -(linear_combination!(
                    E::Fr::zero(),
                    nu,
                    range_index!(1, K, i - (1) + 1),
                    -to_field::<E::Fr>(1),
                    power_vector_index!(gamma, K, i - (1) + 1)
                )) * (vector_index!(h_vec, i)),
                K + S_a + S_b + S_c
            ),
            "The 2'th hadamard check is not satisfied"
        );
        check_vector_eq!(
            expression_vector!(
                i,
                (linear_combination!(
                    E::Fr::zero(),
                    -to_field::<E::Fr>(1),
                    range_index!(1, S_a + S_b + S_c, i - (K + 1) + 1)
                )) * (linear_combination!(
                    E::Fr::zero(),
                    to_field::<E::Fr>(1),
                    range_index!(1, S_a + S_b + S_c, i - (K + 1) + 1)
                )),
                K + S_a + S_b + S_c
            ),
            expression_vector!(
                i,
                -(linear_combination!(
                    E::Fr::zero(),
                    to_field::<E::Fr>(1),
                    vector_index!(h_vec, (i as i64) - (1) as i64 + 1)
                )) * (linear_combination!(
                    linear_combination!(
                        E::Fr::zero(),
                        mu * nu,
                        range_index!(1, S_a + S_b + S_c, i - (K + 1) + 1)
                    ),
                    -mu,
                    vector_index!(pk.w_vec, (i as i64) - (K + 1) as i64 + 1),
                    -nu,
                    vector_index!(pk.u_vec, (i as i64) - (K + 1) as i64 + 1),
                    to_field::<E::Fr>(1),
                    vector_index!(pk.y_vec, (i as i64) - (K + 1) as i64 + 1)
                )),
                K + S_a + S_b + S_c
            ),
            "The 3'th hadamard check is not satisfied"
        );
        check_vector_eq!(
            expression_vector!(
                i,
                (linear_combination!(
                    E::Fr::zero(),
                    -to_field::<E::Fr>(1),
                    range_index!(1, H, i - (-H + K + S_a + S_b + S_c + 1) + 1)
                )) * (linear_combination!(
                    E::Fr::zero(),
                    to_field::<E::Fr>(1),
                    vector_index!(
                        u_vec_1,
                        (i as i64) - (-3 * H + K + S_a + S_b + S_c + 1) as i64 + 1
                    )
                )),
                K + S_a + S_b + S_c
            ),
            expression_vector!(
                i,
                -(linear_combination!(
                    E::Fr::zero(),
                    to_field::<E::Fr>(1),
                    vector_index!(
                        u_vec_1,
                        (i as i64) - (-H + K + S_a + S_b + S_c + 1) as i64 + 1
                    )
                )) * (linear_combination!(
                    E::Fr::zero(),
                    to_field::<E::Fr>(1),
                    vector_index!(
                        u_vec_1,
                        (i as i64) - (-2 * H + K + S_a + S_b + S_c + 1) as i64 + 1
                    )
                )),
                K + S_a + S_b + S_c
            ),
            "The 4'th hadamard check is not satisfied"
        );
        check_vector_eq!(
            expression_vector!(
                i,
                (linear_combination!(
                    E::Fr::zero(),
                    to_field::<E::Fr>(1),
                    range_index!(1, ell + 1, i - (3 * H + 1) + 1)
                )) * (linear_combination!(
                    linear_combination!(multi_delta!(i, -to_field::<E::Fr>(1), 3 * H + 1)),
                    to_field::<E::Fr>(1),
                    vector_index!(u_vec_1, (i as i64) - (1) as i64 + 1),
                    -to_field::<E::Fr>(1),
                    vector_index!(x_vec, (i as i64) - (3 * H + 2) as i64 + 1)
                )),
                K + S_a + S_b + S_c
            ),
            vec!(E::Fr::zero(); (K + S_a + S_b + S_c) as usize),
            "The 5'th hadamard check is not satisfied"
        );
        define_vec!(
            t_vec,
            expression_vector!(
                i,
                sum!(
                    (linear_combination!(
                        E::Fr::zero(),
                        mu,
                        range_index!(1, 3 * H, K + S_a + S_b + S_c + i - (1) + 1),
                        -to_field::<E::Fr>(1),
                        power_vector_index!(gamma, 3 * H, K + S_a + S_b + S_c + i - (1) + 1)
                    )) * (vector_index!(s_vec, K + S_a + S_b + S_c + i)),
                    (linear_combination!(
                        E::Fr::zero(),
                        -to_field::<E::Fr>(1),
                        range_index!(1, 3 * H, K + S_a + S_b + S_c + i - (1) + 1)
                    )) * (range_index!(1, 3 * H, K + S_a + S_b + S_c + i)),
                    (linear_combination!(
                        E::Fr::zero(),
                        alpha * nu,
                        range_index!(1, K, K + S_a + S_b + S_c + i - (1) + 1),
                        -alpha,
                        power_vector_index!(gamma, K, K + S_a + S_b + S_c + i - (1) + 1)
                    )) * (vector_index!(h_vec, K + S_a + S_b + S_c + i)),
                    (linear_combination!(
                        E::Fr::zero(),
                        -alpha,
                        range_index!(1, K, K + S_a + S_b + S_c + i - (1) + 1)
                    )) * (range_index!(1, K, K + S_a + S_b + S_c + i)),
                    (linear_combination!(
                        E::Fr::zero(),
                        power(alpha, 2),
                        vector_index!(h_vec, (K + S_a + S_b + S_c + i as i64) - (1) as i64 + 1)
                    )) * (linear_combination!(
                        linear_combination!(
                            E::Fr::zero(),
                            mu * nu,
                            range_index!(1, S_a + S_b + S_c, K + S_a + S_b + S_c + i - (K + 1) + 1)
                        ),
                        -mu,
                        vector_index!(
                            pk.w_vec,
                            (K + S_a + S_b + S_c + i as i64) - (K + 1) as i64 + 1
                        ),
                        -nu,
                        vector_index!(
                            pk.u_vec,
                            (K + S_a + S_b + S_c + i as i64) - (K + 1) as i64 + 1
                        ),
                        to_field::<E::Fr>(1),
                        vector_index!(
                            pk.y_vec,
                            (K + S_a + S_b + S_c + i as i64) - (K + 1) as i64 + 1
                        )
                    )),
                    (linear_combination!(
                        E::Fr::zero(),
                        -power(alpha, 2),
                        range_index!(1, S_a + S_b + S_c, K + S_a + S_b + S_c + i - (K + 1) + 1)
                    )) * (linear_combination!(
                        E::Fr::zero(),
                        to_field::<E::Fr>(1),
                        range_index!(1, S_a + S_b + S_c, K + S_a + S_b + S_c + i - (K + 1) + 1)
                    )),
                    (linear_combination!(
                        E::Fr::zero(),
                        power(alpha, 3),
                        vector_index!(
                            u_vec_1,
                            (K + S_a + S_b + S_c + i as i64)
                                - (-H + K + S_a + S_b + S_c + 1) as i64
                                + 1
                        )
                    )) * (linear_combination!(
                        E::Fr::zero(),
                        to_field::<E::Fr>(1),
                        vector_index!(
                            u_vec_1,
                            (K + S_a + S_b + S_c + i as i64)
                                - (-2 * H + K + S_a + S_b + S_c + 1) as i64
                                + 1
                        )
                    )),
                    (linear_combination!(
                        E::Fr::zero(),
                        -power(alpha, 3),
                        range_index!(
                            1,
                            H,
                            K + S_a + S_b + S_c + i - (-H + K + S_a + S_b + S_c + 1) + 1
                        )
                    )) * (linear_combination!(
                        E::Fr::zero(),
                        to_field::<E::Fr>(1),
                        vector_index!(
                            u_vec_1,
                            (K + S_a + S_b + S_c + i as i64)
                                - (-3 * H + K + S_a + S_b + S_c + 1) as i64
                                + 1
                        )
                    )),
                    (linear_combination!(
                        E::Fr::zero(),
                        power(alpha, 4),
                        range_index!(1, ell + 1, K + S_a + S_b + S_c + i - (3 * H + 1) + 1)
                    )) * (linear_combination!(
                        linear_combination!(multi_delta!(
                            K + S_a + S_b + S_c + i,
                            -to_field::<E::Fr>(1),
                            3 * H + 1
                        )),
                        to_field::<E::Fr>(1),
                        vector_index!(u_vec_1, (K + S_a + S_b + S_c + i as i64) - (1) as i64 + 1),
                        -to_field::<E::Fr>(1),
                        vector_index!(
                            x_vec,
                            (K + S_a + S_b + S_c + i as i64) - (3 * H + 2) as i64 + 1
                        )
                    )),
                    (linear_combination!(
                        E::Fr::zero(),
                        power(alpha, 5),
                        vector_index!(
                            u_vec_1,
                            (K + S_a + S_b + S_c + i as i64)
                                - (-3 * H + S_a + S_b + S_c + 1) as i64
                                + 1
                        )
                    )) * (linear_combination!(
                        E::Fr::zero(),
                        to_field::<E::Fr>(1),
                        vector_index!(
                            s_vec,
                            (K + S_a + S_b + S_c + i as i64)
                                - (-3 * H + S_a + S_b + S_c + 1) as i64
                                + 1
                        )
                    )),
                    (linear_combination!(
                        E::Fr::zero(),
                        -power(alpha, 5) * beta,
                        vector_index!(
                            h_vec,
                            (K + S_a + S_b + S_c + i as i64) - (S_a + S_b + S_c + 1) as i64 + 1
                        )
                    )) * (linear_combination!(
                        E::Fr::zero(),
                        to_field::<E::Fr>(1),
                        vector_index!(
                            s_vec,
                            (K + S_a + S_b + S_c + i as i64)
                                - (-3 * H + S_a + S_b + S_c + 1) as i64
                                + 1
                        )
                    )),
                    (linear_combination!(
                        E::Fr::zero(),
                        -power(alpha, 5) * beta,
                        vector_index!(h_vec, (K + S_a + S_b + S_c + i as i64) - (1) as i64 + 1)
                    )) * (linear_combination!(
                        E::Fr::zero(),
                        to_field::<E::Fr>(1),
                        vector_index!(
                            pk.v_vec,
                            (K + S_a + S_b + S_c + i as i64) - (K + 1) as i64 + 1
                        )
                    )),
                    (linear_combination!(
                        E::Fr::zero(),
                        -power(alpha, 5),
                        vector_index!(
                            r_vec_tilde,
                            (K + S_a + S_b + S_c + i as i64) - (1) as i64 + 1
                        ),
                        power(alpha, 5),
                        vector_index!(
                            r_vec_tilde,
                            (K + S_a + S_b + S_c + i as i64) - (2) as i64 + 1
                        )
                    )) * (range_index!(1, K + S_a + S_b + S_c, K + S_a + S_b + S_c + i))
                ),
                S_a + S_b + S_c + 2
            )
        );
        define_vec!(t_vec_1, vector_concat!(delta_vec_4, t_vec));
        let cm_t_vec_1 = vector_to_commitment::<E>(&pk.powers, &t_vec_1).unwrap();
        let omega = hash_to_field::<E::Fr>(
            to_bytes!(
                x_vec,
                pk.verifier_key.cm_u_vec,
                pk.verifier_key.cm_w_vec,
                pk.verifier_key.cm_v_vec,
                pk.verifier_key.cm_y_vec,
                cm_u_vec_1,
                cm_s_vec,
                cm_h_vec,
                cm_r_vec_tilde,
                cm_t_vec_1
            )
            .unwrap(),
        );
        let mut sum_vec = vec![E::Fr::zero(); (K + 2 * S_a + 2 * S_b + 2 * S_c + 1) as usize];
        let mut hcheck_vec =
            vec![E::Fr::zero(); (2 * K + 4 * S_a + 4 * S_b + 4 * S_c + 1) as usize];
        add_expression_vector_to_vector!(
            sum_vec,
            i,
            (linear_combination!(linear_combination!(
                E::Fr::zero(),
                mu,
                range_index!(1, 3 * H, i - (1) + 1),
                -to_field::<E::Fr>(1),
                power_vector_index!(gamma, 3 * H, i - (1) + 1)
            ))) * (linear_combination!(
                E::Fr::zero(),
                to_field::<E::Fr>(1),
                vector_index!(s_vec, (i as i64) - (1) as i64 + 1)
            ))
        );
        let abnaive_vec = vector_poly_mul!(
            expression_vector!(
                i,
                linear_combination!(linear_combination!(
                    E::Fr::zero(),
                    mu,
                    range_index!(1, 3 * H, i - (1) + 1),
                    -to_field::<E::Fr>(1),
                    power_vector_index!(gamma, 3 * H, i - (1) + 1)
                )),
                K + 2 * S_a + 2 * S_b + 2 * S_c + 1
            ),
            expression_vector!(
                i,
                linear_combination!(
                    E::Fr::zero(),
                    to_field::<E::Fr>(1),
                    vector_index!(s_vec, (i as i64) - (1) as i64 + 1)
                ),
                K + 2 * S_a + 2 * S_b + 2 * S_c + 1
            ),
            omega
        );
        add_vector_to_vector!(hcheck_vec, abnaive_vec);
        let v_vec_1 = vector_power_mul!(s_vec, omega.inverse().unwrap(), 3 * H);
        let v_vec_2 = vector_power_mul!(s_vec, to_field::<E::Fr>(1) / (gamma * omega), 3 * H);
        // The vector pair here is \mu\cdot \vec{1}^{3 H}-\vec{\gamma}^{3 H} and \vec{s}
        let atimesb_vec = expression_vector!(
            i,
            linear_combination!(
                E::Fr::zero(),
                mu * power(omega, 3 * H - 1),
                vector_index!(
                    v_vec_1,
                    (-K - 2 * S_a - 2 * S_b - 2 * S_c + i as i64) - (2 - 3 * H) as i64 + 1
                ),
                -power(gamma * omega, 3 * H - 1),
                vector_index!(
                    v_vec_2,
                    (-K - 2 * S_a - 2 * S_b - 2 * S_c + i as i64) - (2 - 3 * H) as i64 + 1
                )
            ),
            2 * K + 4 * S_a + 4 * S_b + 4 * S_c + 1
        );
        check_vector_eq!(
            atimesb_vec,
            zero_pad!(abnaive_vec, 2 * K + 4 * S_a + 4 * S_b + 4 * S_c + 1),
            "The 1'th convolution is incorrect"
        );
        add_expression_vector_to_vector!(
            sum_vec,
            i,
            (linear_combination!(linear_combination!(
                E::Fr::zero(),
                -to_field::<E::Fr>(1),
                range_index!(1, 3 * H, i - (1) + 1)
            ))) * (linear_combination!(linear_combination!(
                E::Fr::zero(),
                to_field::<E::Fr>(1),
                range_index!(1, 3 * H, i - (1) + 1)
            )))
        );
        let abnaive_vec_1 = vector_poly_mul!(
            expression_vector!(
                i,
                linear_combination!(linear_combination!(
                    E::Fr::zero(),
                    -to_field::<E::Fr>(1),
                    range_index!(1, 3 * H, i - (1) + 1)
                )),
                K + 2 * S_a + 2 * S_b + 2 * S_c + 1
            ),
            expression_vector!(
                i,
                linear_combination!(linear_combination!(
                    E::Fr::zero(),
                    to_field::<E::Fr>(1),
                    range_index!(1, 3 * H, i - (1) + 1)
                )),
                K + 2 * S_a + 2 * S_b + 2 * S_c + 1
            ),
            omega
        );
        add_vector_to_vector!(hcheck_vec, abnaive_vec_1);
        let v_vec_3 =
            power_power_mul!(omega.inverse().unwrap(), 3 * H, to_field::<E::Fr>(1), 3 * H);
        // The vector pair here is -\vec{1}^{3 H} and \vec{1}^{3 H}
        let atimesb_vec_1 = expression_vector!(
            i,
            linear_combination!(
                E::Fr::zero(),
                -power(omega, 3 * H - 1),
                vector_index!(
                    v_vec_3,
                    (-K - 2 * S_a - 2 * S_b - 2 * S_c + i as i64) - (2 - 3 * H) as i64 + 1
                )
            ),
            2 * K + 4 * S_a + 4 * S_b + 4 * S_c + 1
        );
        check_vector_eq!(
            atimesb_vec_1,
            zero_pad!(abnaive_vec_1, 2 * K + 4 * S_a + 4 * S_b + 4 * S_c + 1),
            "The 2'th convolution is incorrect"
        );
        add_expression_vector_to_vector!(
            sum_vec,
            i,
            (linear_combination!(linear_combination!(
                E::Fr::zero(),
                alpha * nu,
                range_index!(1, K, i - (1) + 1),
                -alpha,
                power_vector_index!(gamma, K, i - (1) + 1)
            ))) * (linear_combination!(
                E::Fr::zero(),
                to_field::<E::Fr>(1),
                vector_index!(h_vec, (i as i64) - (1) as i64 + 1)
            ))
        );
        let abnaive_vec_2 = vector_poly_mul!(
            expression_vector!(
                i,
                linear_combination!(linear_combination!(
                    E::Fr::zero(),
                    alpha * nu,
                    range_index!(1, K, i - (1) + 1),
                    -alpha,
                    power_vector_index!(gamma, K, i - (1) + 1)
                )),
                K + 2 * S_a + 2 * S_b + 2 * S_c + 1
            ),
            expression_vector!(
                i,
                linear_combination!(
                    E::Fr::zero(),
                    to_field::<E::Fr>(1),
                    vector_index!(h_vec, (i as i64) - (1) as i64 + 1)
                ),
                K + 2 * S_a + 2 * S_b + 2 * S_c + 1
            ),
            omega
        );
        add_vector_to_vector!(hcheck_vec, abnaive_vec_2);
        let v_vec_4 = vector_power_mul!(h_vec, omega.inverse().unwrap(), K);
        let v_vec_5 = vector_power_mul!(h_vec, to_field::<E::Fr>(1) / (gamma * omega), K);
        // The vector pair here is \alpha \nu\cdot \vec{1}^{K}- \alpha\cdot \vec{\gamma}^{K} and \vec{h}
        let atimesb_vec_2 = expression_vector!(
            i,
            linear_combination!(
                E::Fr::zero(),
                alpha * nu * power(omega, K - 1),
                vector_index!(
                    v_vec_4,
                    (-K - 2 * S_a - 2 * S_b - 2 * S_c + i as i64) - (2 - K) as i64 + 1
                ),
                -alpha * power(gamma * omega, K - 1),
                vector_index!(
                    v_vec_5,
                    (-K - 2 * S_a - 2 * S_b - 2 * S_c + i as i64) - (2 - K) as i64 + 1
                )
            ),
            2 * K + 4 * S_a + 4 * S_b + 4 * S_c + 1
        );
        check_vector_eq!(
            atimesb_vec_2,
            zero_pad!(abnaive_vec_2, 2 * K + 4 * S_a + 4 * S_b + 4 * S_c + 1),
            "The 3'th convolution is incorrect"
        );
        add_expression_vector_to_vector!(
            sum_vec,
            i,
            (linear_combination!(linear_combination!(
                E::Fr::zero(),
                -alpha,
                range_index!(1, K, i - (1) + 1)
            ))) * (linear_combination!(linear_combination!(
                E::Fr::zero(),
                to_field::<E::Fr>(1),
                range_index!(1, K, i - (1) + 1)
            )))
        );
        let abnaive_vec_3 = vector_poly_mul!(
            expression_vector!(
                i,
                linear_combination!(linear_combination!(
                    E::Fr::zero(),
                    -alpha,
                    range_index!(1, K, i - (1) + 1)
                )),
                K + 2 * S_a + 2 * S_b + 2 * S_c + 1
            ),
            expression_vector!(
                i,
                linear_combination!(linear_combination!(
                    E::Fr::zero(),
                    to_field::<E::Fr>(1),
                    range_index!(1, K, i - (1) + 1)
                )),
                K + 2 * S_a + 2 * S_b + 2 * S_c + 1
            ),
            omega
        );
        add_vector_to_vector!(hcheck_vec, abnaive_vec_3);
        let v_vec_6 = power_power_mul!(omega.inverse().unwrap(), K, to_field::<E::Fr>(1), K);
        // The vector pair here is - \alpha\cdot \vec{1}^{K} and \vec{1}^{K}
        let atimesb_vec_3 = expression_vector!(
            i,
            linear_combination!(
                E::Fr::zero(),
                -alpha * power(omega, K - 1),
                vector_index!(
                    v_vec_6,
                    (-K - 2 * S_a - 2 * S_b - 2 * S_c + i as i64) - (2 - K) as i64 + 1
                )
            ),
            2 * K + 4 * S_a + 4 * S_b + 4 * S_c + 1
        );
        check_vector_eq!(
            atimesb_vec_3,
            zero_pad!(abnaive_vec_3, 2 * K + 4 * S_a + 4 * S_b + 4 * S_c + 1),
            "The 4'th convolution is incorrect"
        );
        add_expression_vector_to_vector!(
            sum_vec,
            i,
            (linear_combination!(
                E::Fr::zero(),
                power(alpha, 2),
                vector_index!(h_vec, (i as i64) - (1) as i64 + 1)
            )) * (linear_combination!(
                linear_combination!(
                    E::Fr::zero(),
                    mu * nu,
                    range_index!(1, S_a + S_b + S_c, i - (K + 1) + 1)
                ),
                -mu,
                vector_index!(pk.w_vec, (i as i64) - (K + 1) as i64 + 1),
                -nu,
                vector_index!(pk.u_vec, (i as i64) - (K + 1) as i64 + 1),
                to_field::<E::Fr>(1),
                vector_index!(pk.y_vec, (i as i64) - (K + 1) as i64 + 1)
            ))
        );
        let abnaive_vec_4 = vector_poly_mul!(
            expression_vector!(
                i,
                linear_combination!(
                    E::Fr::zero(),
                    power(alpha, 2),
                    vector_index!(h_vec, (i as i64) - (1) as i64 + 1)
                ),
                K + 2 * S_a + 2 * S_b + 2 * S_c + 1
            ),
            expression_vector!(
                i,
                linear_combination!(
                    linear_combination!(
                        E::Fr::zero(),
                        mu * nu,
                        range_index!(1, S_a + S_b + S_c, i - (K + 1) + 1)
                    ),
                    -mu,
                    vector_index!(pk.w_vec, (i as i64) - (K + 1) as i64 + 1),
                    -nu,
                    vector_index!(pk.u_vec, (i as i64) - (K + 1) as i64 + 1),
                    to_field::<E::Fr>(1),
                    vector_index!(pk.y_vec, (i as i64) - (K + 1) as i64 + 1)
                ),
                K + 2 * S_a + 2 * S_b + 2 * S_c + 1
            ),
            omega
        );
        add_vector_to_vector!(hcheck_vec, abnaive_vec_4);
        let v_vec_7 = vector_poly_mul!(h_vec, pk.w_vec, omega).coeffs;
        let shiftlength = h_vec.len() as i64 - 1;
        let v_vec_8 = vector_reverse_omega!(h_vec, omega);
        let shiftlength_1 = h_vec.len() as i64 - 1;
        let v_vec_9 = vector_poly_mul!(h_vec, pk.u_vec, omega).coeffs;
        let shiftlength_2 = h_vec.len() as i64 - 1;
        let v_vec_10 = vector_poly_mul!(h_vec, pk.y_vec, omega).coeffs;
        let shiftlength_3 = h_vec.len() as i64 - 1;
        let v_vec_11 = vector_power_mul!(v_vec_8, to_field::<E::Fr>(1), S_a + S_b + S_c);
        // The vector pair here is \alpha^{2}\cdot \vec{h} and - \mu\cdot {\vec{w}}^{\to K}- \nu\cdot {\vec{u}}^{\to K}+{\vec{y}}^{\to K}+\mu \nu\cdot {\vec{1}^{S_{a} + S_{b} + S_{c}}}^{\to K}
        let atimesb_vec_4 = expression_vector!(
            i,
            linear_combination!(
                E::Fr::zero(),
                -power(alpha, 2) * mu,
                vector_index!(
                    v_vec_7,
                    (-K - 2 * S_a - 2 * S_b - 2 * S_c + i as i64) - (K - shiftlength + 1) as i64
                        + 1
                ),
                -power(alpha, 2) * nu,
                vector_index!(
                    v_vec_9,
                    (-K - 2 * S_a - 2 * S_b - 2 * S_c + i as i64) - (K - shiftlength_2 + 1) as i64
                        + 1
                ),
                power(alpha, 2),
                vector_index!(
                    v_vec_10,
                    (-K - 2 * S_a - 2 * S_b - 2 * S_c + i as i64) - (K - shiftlength_3 + 1) as i64
                        + 1
                ),
                power(alpha, 2) * mu * nu,
                vector_index!(
                    v_vec_11,
                    (-K - 2 * S_a - 2 * S_b - 2 * S_c + i as i64) - (K - shiftlength_1 + 1) as i64
                        + 1
                )
            ),
            2 * K + 4 * S_a + 4 * S_b + 4 * S_c + 1
        );
        check_vector_eq!(
            atimesb_vec_4,
            zero_pad!(abnaive_vec_4, 2 * K + 4 * S_a + 4 * S_b + 4 * S_c + 1),
            "The 5'th convolution is incorrect"
        );
        add_expression_vector_to_vector!(
            sum_vec,
            i,
            (linear_combination!(linear_combination!(
                E::Fr::zero(),
                -power(alpha, 2),
                range_index!(1, S_a + S_b + S_c, i - (K + 1) + 1)
            ))) * (linear_combination!(linear_combination!(
                E::Fr::zero(),
                to_field::<E::Fr>(1),
                range_index!(1, S_a + S_b + S_c, i - (K + 1) + 1)
            )))
        );
        let abnaive_vec_5 = vector_poly_mul!(
            expression_vector!(
                i,
                linear_combination!(linear_combination!(
                    E::Fr::zero(),
                    -power(alpha, 2),
                    range_index!(1, S_a + S_b + S_c, i - (K + 1) + 1)
                )),
                K + 2 * S_a + 2 * S_b + 2 * S_c + 1
            ),
            expression_vector!(
                i,
                linear_combination!(linear_combination!(
                    E::Fr::zero(),
                    to_field::<E::Fr>(1),
                    range_index!(1, S_a + S_b + S_c, i - (K + 1) + 1)
                )),
                K + 2 * S_a + 2 * S_b + 2 * S_c + 1
            ),
            omega
        );
        add_vector_to_vector!(hcheck_vec, abnaive_vec_5);
        let v_vec_12 = power_power_mul!(
            omega.inverse().unwrap(),
            S_a + S_b + S_c,
            to_field::<E::Fr>(1),
            S_a + S_b + S_c
        );
        // The vector pair here is - \alpha^{2}\cdot {\vec{1}^{S_{a} + S_{b} + S_{c}}}^{\to K} and {\vec{1}^{S_{a} + S_{b} + S_{c}}}^{\to K}
        let atimesb_vec_5 = expression_vector!(
            i,
            linear_combination!(
                E::Fr::zero(),
                -power(alpha, 2) * power(omega, K + S_a + S_b + S_c - 1),
                vector_index!(
                    v_vec_12,
                    (-K - 2 * S_a - 2 * S_b - 2 * S_c + i as i64) - (-S_a - S_b - S_c + 2) as i64
                        + 1
                )
            ),
            2 * K + 4 * S_a + 4 * S_b + 4 * S_c + 1
        );
        check_vector_eq!(
            atimesb_vec_5,
            zero_pad!(abnaive_vec_5, 2 * K + 4 * S_a + 4 * S_b + 4 * S_c + 1),
            "The 6'th convolution is incorrect"
        );
        add_expression_vector_to_vector!(
            sum_vec,
            i,
            (linear_combination!(
                E::Fr::zero(),
                power(alpha, 3),
                vector_index!(
                    u_vec_1,
                    (i as i64) - (-H + K + S_a + S_b + S_c + 1) as i64 + 1
                )
            )) * (linear_combination!(
                E::Fr::zero(),
                to_field::<E::Fr>(1),
                vector_index!(
                    u_vec_1,
                    (i as i64) - (-2 * H + K + S_a + S_b + S_c + 1) as i64 + 1
                )
            ))
        );
        let abnaive_vec_6 = vector_poly_mul!(
            expression_vector!(
                i,
                linear_combination!(
                    E::Fr::zero(),
                    power(alpha, 3),
                    vector_index!(
                        u_vec_1,
                        (i as i64) - (-H + K + S_a + S_b + S_c + 1) as i64 + 1
                    )
                ),
                K + 2 * S_a + 2 * S_b + 2 * S_c + 1
            ),
            expression_vector!(
                i,
                linear_combination!(
                    E::Fr::zero(),
                    to_field::<E::Fr>(1),
                    vector_index!(
                        u_vec_1,
                        (i as i64) - (-2 * H + K + S_a + S_b + S_c + 1) as i64 + 1
                    )
                ),
                K + 2 * S_a + 2 * S_b + 2 * S_c + 1
            ),
            omega
        );
        add_vector_to_vector!(hcheck_vec, abnaive_vec_6);
        let v_vec_13 = vector_poly_mul!(u_vec_1, u_vec_1, omega).coeffs;
        let shiftlength_4 = u_vec_1.len() as i64 - 1;
        // The vector pair here is \alpha^{3}\cdot {{\vec{u}}_{\mathtt{\text{1}}}}^{\to - H + K + S_{a} + S_{b} + S_{c}} and {{\vec{u}}_{\mathtt{\text{1}}}}^{\to - 2 H + K + S_{a} + S_{b} + S_{c}}
        let atimesb_vec_6 = expression_vector!(
            i,
            linear_combination!(
                E::Fr::zero(),
                power(alpha, 3) * power(omega, -H + K + S_a + S_b + S_c),
                vector_index!(
                    v_vec_13,
                    (-K - 2 * S_a - 2 * S_b - 2 * S_c + i as i64) - (-H - shiftlength_4 + 1) as i64
                        + 1
                )
            ),
            2 * K + 4 * S_a + 4 * S_b + 4 * S_c + 1
        );
        check_vector_eq!(
            atimesb_vec_6,
            zero_pad!(abnaive_vec_6, 2 * K + 4 * S_a + 4 * S_b + 4 * S_c + 1),
            "The 7'th convolution is incorrect"
        );
        add_expression_vector_to_vector!(
            sum_vec,
            i,
            (linear_combination!(linear_combination!(
                E::Fr::zero(),
                -power(alpha, 3),
                range_index!(1, H, i - (-H + K + S_a + S_b + S_c + 1) + 1)
            ))) * (linear_combination!(
                E::Fr::zero(),
                to_field::<E::Fr>(1),
                vector_index!(
                    u_vec_1,
                    (i as i64) - (-3 * H + K + S_a + S_b + S_c + 1) as i64 + 1
                )
            ))
        );
        let abnaive_vec_7 = vector_poly_mul!(
            expression_vector!(
                i,
                linear_combination!(linear_combination!(
                    E::Fr::zero(),
                    -power(alpha, 3),
                    range_index!(1, H, i - (-H + K + S_a + S_b + S_c + 1) + 1)
                )),
                K + 2 * S_a + 2 * S_b + 2 * S_c + 1
            ),
            expression_vector!(
                i,
                linear_combination!(
                    E::Fr::zero(),
                    to_field::<E::Fr>(1),
                    vector_index!(
                        u_vec_1,
                        (i as i64) - (-3 * H + K + S_a + S_b + S_c + 1) as i64 + 1
                    )
                ),
                K + 2 * S_a + 2 * S_b + 2 * S_c + 1
            ),
            omega
        );
        add_vector_to_vector!(hcheck_vec, abnaive_vec_7);
        let v_vec_14 = vector_power_mul!(u_vec_1, omega.inverse().unwrap(), H);
        // The vector pair here is - \alpha^{3}\cdot {\vec{1}^{H}}^{\to - H + K + S_{a} + S_{b} + S_{c}} and {{\vec{u}}_{\mathtt{\text{1}}}}^{\to - 3 H + K + S_{a} + S_{b} + S_{c}}
        let atimesb_vec_7 = expression_vector!(
            i,
            linear_combination!(
                E::Fr::zero(),
                -power(alpha, 3) * power(omega, K + S_a + S_b + S_c - 1),
                vector_index!(
                    v_vec_14,
                    (-K - 2 * S_a - 2 * S_b - 2 * S_c + i as i64) - (2 - 3 * H) as i64 + 1
                )
            ),
            2 * K + 4 * S_a + 4 * S_b + 4 * S_c + 1
        );
        check_vector_eq!(
            atimesb_vec_7,
            zero_pad!(abnaive_vec_7, 2 * K + 4 * S_a + 4 * S_b + 4 * S_c + 1),
            "The 8'th convolution is incorrect"
        );
        add_expression_vector_to_vector!(
            sum_vec,
            i,
            (linear_combination!(linear_combination!(
                E::Fr::zero(),
                power(alpha, 4),
                range_index!(1, ell + 1, i - (3 * H + 1) + 1)
            ))) * (linear_combination!(
                linear_combination!(multi_delta!(i, -to_field::<E::Fr>(1), 3 * H + 1)),
                to_field::<E::Fr>(1),
                vector_index!(u_vec_1, (i as i64) - (1) as i64 + 1),
                -to_field::<E::Fr>(1),
                vector_index!(x_vec, (i as i64) - (3 * H + 2) as i64 + 1)
            ))
        );
        let abnaive_vec_8 = vector_poly_mul!(
            expression_vector!(
                i,
                linear_combination!(linear_combination!(
                    E::Fr::zero(),
                    power(alpha, 4),
                    range_index!(1, ell + 1, i - (3 * H + 1) + 1)
                )),
                K + 2 * S_a + 2 * S_b + 2 * S_c + 1
            ),
            expression_vector!(
                i,
                linear_combination!(
                    linear_combination!(multi_delta!(i, -to_field::<E::Fr>(1), 3 * H + 1)),
                    to_field::<E::Fr>(1),
                    vector_index!(u_vec_1, (i as i64) - (1) as i64 + 1),
                    -to_field::<E::Fr>(1),
                    vector_index!(x_vec, (i as i64) - (3 * H + 2) as i64 + 1)
                ),
                K + 2 * S_a + 2 * S_b + 2 * S_c + 1
            ),
            omega
        );
        add_vector_to_vector!(hcheck_vec, abnaive_vec_8);
        let v_vec_15 = vector_power_mul!(u_vec_1, omega.inverse().unwrap(), ell + 1);
        let v_vec_16 = vector_power_mul!(x_vec, omega.inverse().unwrap(), ell + 1);
        // The vector pair here is \alpha^{4}\cdot {\vec{1}^{\ell + 1}}^{\to 3 H} and {\vec{u}}_{\mathtt{\text{1}}}-{\vec{x}}^{\to 3 H + 1}-\vec{e}_{3 H + 1}
        let atimesb_vec_8 = expression_vector!(
            i,
            linear_combination!(
                linear_combination!(
                    E::Fr::zero(),
                    -power(alpha, 4) * power(omega, 3 * H + ell),
                    power_vector_index!(
                        omega.inverse().unwrap(),
                        ell + 1,
                        -K - 2 * S_a - 2 * S_b - 2 * S_c + i - (1 - ell) + 1
                    )
                ),
                power(alpha, 4) * power(omega, 3 * H + ell),
                vector_index!(
                    v_vec_15,
                    (-K - 2 * S_a - 2 * S_b - 2 * S_c + i as i64) - (-3 * H - ell + 1) as i64 + 1
                ),
                -power(alpha, 4) * power(omega, 3 * H + ell),
                vector_index!(
                    v_vec_16,
                    (-K - 2 * S_a - 2 * S_b - 2 * S_c + i as i64) - (2 - ell) as i64 + 1
                )
            ),
            2 * K + 4 * S_a + 4 * S_b + 4 * S_c + 1
        );
        check_vector_eq!(
            atimesb_vec_8,
            zero_pad!(abnaive_vec_8, 2 * K + 4 * S_a + 4 * S_b + 4 * S_c + 1),
            "The 9'th convolution is incorrect"
        );
        add_expression_vector_to_vector!(
            sum_vec,
            i,
            (linear_combination!(
                E::Fr::zero(),
                power(alpha, 5),
                vector_index!(
                    u_vec_1,
                    (i as i64) - (-3 * H + S_a + S_b + S_c + 1) as i64 + 1
                )
            )) * (linear_combination!(
                E::Fr::zero(),
                to_field::<E::Fr>(1),
                vector_index!(
                    s_vec,
                    (i as i64) - (-3 * H + S_a + S_b + S_c + 1) as i64 + 1
                )
            ))
        );
        let abnaive_vec_9 = vector_poly_mul!(
            expression_vector!(
                i,
                linear_combination!(
                    E::Fr::zero(),
                    power(alpha, 5),
                    vector_index!(
                        u_vec_1,
                        (i as i64) - (-3 * H + S_a + S_b + S_c + 1) as i64 + 1
                    )
                ),
                K + 2 * S_a + 2 * S_b + 2 * S_c + 1
            ),
            expression_vector!(
                i,
                linear_combination!(
                    E::Fr::zero(),
                    to_field::<E::Fr>(1),
                    vector_index!(
                        s_vec,
                        (i as i64) - (-3 * H + S_a + S_b + S_c + 1) as i64 + 1
                    )
                ),
                K + 2 * S_a + 2 * S_b + 2 * S_c + 1
            ),
            omega
        );
        add_vector_to_vector!(hcheck_vec, abnaive_vec_9);
        let v_vec_17 = vector_poly_mul!(u_vec_1, s_vec, omega).coeffs;
        let shiftlength_5 = u_vec_1.len() as i64 - 1;
        // The vector pair here is \alpha^{5}\cdot {{\vec{u}}_{\mathtt{\text{1}}}}^{\to - 3 H + S_{a} + S_{b} + S_{c}} and {\vec{s}}^{\to - 3 H + S_{a} + S_{b} + S_{c}}
        let atimesb_vec_9 = expression_vector!(
            i,
            linear_combination!(
                E::Fr::zero(),
                power(alpha, 5) * power(omega, -3 * H + S_a + S_b + S_c),
                vector_index!(
                    v_vec_17,
                    (-K - 2 * S_a - 2 * S_b - 2 * S_c + i as i64) - (1 - shiftlength_5) as i64 + 1
                )
            ),
            2 * K + 4 * S_a + 4 * S_b + 4 * S_c + 1
        );
        check_vector_eq!(
            atimesb_vec_9,
            zero_pad!(abnaive_vec_9, 2 * K + 4 * S_a + 4 * S_b + 4 * S_c + 1),
            "The 10'th convolution is incorrect"
        );
        add_expression_vector_to_vector!(
            sum_vec,
            i,
            (linear_combination!(
                E::Fr::zero(),
                -power(alpha, 5) * beta,
                vector_index!(h_vec, (i as i64) - (S_a + S_b + S_c + 1) as i64 + 1)
            )) * (linear_combination!(
                E::Fr::zero(),
                to_field::<E::Fr>(1),
                vector_index!(
                    s_vec,
                    (i as i64) - (-3 * H + S_a + S_b + S_c + 1) as i64 + 1
                )
            ))
        );
        let abnaive_vec_10 = vector_poly_mul!(
            expression_vector!(
                i,
                linear_combination!(
                    E::Fr::zero(),
                    -power(alpha, 5) * beta,
                    vector_index!(h_vec, (i as i64) - (S_a + S_b + S_c + 1) as i64 + 1)
                ),
                K + 2 * S_a + 2 * S_b + 2 * S_c + 1
            ),
            expression_vector!(
                i,
                linear_combination!(
                    E::Fr::zero(),
                    to_field::<E::Fr>(1),
                    vector_index!(
                        s_vec,
                        (i as i64) - (-3 * H + S_a + S_b + S_c + 1) as i64 + 1
                    )
                ),
                K + 2 * S_a + 2 * S_b + 2 * S_c + 1
            ),
            omega
        );
        add_vector_to_vector!(hcheck_vec, abnaive_vec_10);
        let v_vec_18 = vector_poly_mul!(h_vec, s_vec, omega).coeffs;
        let shiftlength_6 = h_vec.len() as i64 - 1;
        // The vector pair here is - \alpha^{5} \beta\cdot {\vec{h}}^{\to S_{a} + S_{b} + S_{c}} and {\vec{s}}^{\to - 3 H + S_{a} + S_{b} + S_{c}}
        let atimesb_vec_10 = expression_vector!(
            i,
            linear_combination!(
                E::Fr::zero(),
                -power(alpha, 5) * beta * power(omega, S_a + S_b + S_c),
                vector_index!(
                    v_vec_18,
                    (-K - 2 * S_a - 2 * S_b - 2 * S_c + i as i64)
                        - (-3 * H - shiftlength_6 + 1) as i64
                        + 1
                )
            ),
            2 * K + 4 * S_a + 4 * S_b + 4 * S_c + 1
        );
        check_vector_eq!(
            atimesb_vec_10,
            zero_pad!(abnaive_vec_10, 2 * K + 4 * S_a + 4 * S_b + 4 * S_c + 1),
            "The 11'th convolution is incorrect"
        );
        add_expression_vector_to_vector!(
            sum_vec,
            i,
            (linear_combination!(
                E::Fr::zero(),
                -power(alpha, 5) * beta,
                vector_index!(h_vec, (i as i64) - (1) as i64 + 1)
            )) * (linear_combination!(
                E::Fr::zero(),
                to_field::<E::Fr>(1),
                vector_index!(pk.v_vec, (i as i64) - (K + 1) as i64 + 1)
            ))
        );
        let abnaive_vec_11 = vector_poly_mul!(
            expression_vector!(
                i,
                linear_combination!(
                    E::Fr::zero(),
                    -power(alpha, 5) * beta,
                    vector_index!(h_vec, (i as i64) - (1) as i64 + 1)
                ),
                K + 2 * S_a + 2 * S_b + 2 * S_c + 1
            ),
            expression_vector!(
                i,
                linear_combination!(
                    E::Fr::zero(),
                    to_field::<E::Fr>(1),
                    vector_index!(pk.v_vec, (i as i64) - (K + 1) as i64 + 1)
                ),
                K + 2 * S_a + 2 * S_b + 2 * S_c + 1
            ),
            omega
        );
        add_vector_to_vector!(hcheck_vec, abnaive_vec_11);
        let v_vec_19 = vector_poly_mul!(h_vec, pk.v_vec, omega).coeffs;
        let shiftlength_7 = h_vec.len() as i64 - 1;
        // The vector pair here is - \alpha^{5} \beta\cdot \vec{h} and {\vec{v}}^{\to K}
        let atimesb_vec_11 = expression_vector!(
            i,
            linear_combination!(
                E::Fr::zero(),
                -power(alpha, 5) * beta,
                vector_index!(
                    v_vec_19,
                    (-K - 2 * S_a - 2 * S_b - 2 * S_c + i as i64) - (K - shiftlength_7 + 1) as i64
                        + 1
                )
            ),
            2 * K + 4 * S_a + 4 * S_b + 4 * S_c + 1
        );
        check_vector_eq!(
            atimesb_vec_11,
            zero_pad!(abnaive_vec_11, 2 * K + 4 * S_a + 4 * S_b + 4 * S_c + 1),
            "The 12'th convolution is incorrect"
        );
        add_expression_vector_to_vector!(
            sum_vec,
            i,
            (linear_combination!(
                E::Fr::zero(),
                -power(alpha, 5),
                vector_index!(r_vec_tilde, (i as i64) - (1) as i64 + 1),
                power(alpha, 5),
                vector_index!(r_vec_tilde, (i as i64) - (2) as i64 + 1)
            )) * (linear_combination!(linear_combination!(
                E::Fr::zero(),
                to_field::<E::Fr>(1),
                range_index!(1, K + S_a + S_b + S_c, i - (1) + 1)
            )))
        );
        let abnaive_vec_12 = vector_poly_mul!(
            expression_vector!(
                i,
                linear_combination!(
                    E::Fr::zero(),
                    -power(alpha, 5),
                    vector_index!(r_vec_tilde, (i as i64) - (1) as i64 + 1),
                    power(alpha, 5),
                    vector_index!(r_vec_tilde, (i as i64) - (2) as i64 + 1)
                ),
                K + 2 * S_a + 2 * S_b + 2 * S_c + 1
            ),
            expression_vector!(
                i,
                linear_combination!(linear_combination!(
                    E::Fr::zero(),
                    to_field::<E::Fr>(1),
                    range_index!(1, K + S_a + S_b + S_c, i - (1) + 1)
                )),
                K + 2 * S_a + 2 * S_b + 2 * S_c + 1
            ),
            omega
        );
        add_vector_to_vector!(hcheck_vec, abnaive_vec_12);
        let v_vec_20 = vector_reverse_omega!(r_vec_tilde, omega);
        let shiftlength_8 = r_vec_tilde.len() as i64 - 1;
        let v_vec_21 = vector_power_mul!(v_vec_20, to_field::<E::Fr>(1), K + S_a + S_b + S_c);
        // The vector pair here is - \alpha^{5}\cdot \tilde{\vec{r}}+\alpha^{5}\cdot {\tilde{\vec{r}}}^{\to 1} and \vec{1}^{K + S_{a} + S_{b} + S_{c}}
        let atimesb_vec_12 = expression_vector!(
            i,
            linear_combination!(
                E::Fr::zero(),
                -power(alpha, 5),
                vector_index!(
                    v_vec_21,
                    (-K - 2 * S_a - 2 * S_b - 2 * S_c + i as i64) - (1 - shiftlength_8) as i64 + 1
                ),
                power(alpha, 5) * omega,
                vector_index!(
                    v_vec_21,
                    (-K - 2 * S_a - 2 * S_b - 2 * S_c + i as i64) - (-shiftlength_8) as i64 + 1
                )
            ),
            2 * K + 4 * S_a + 4 * S_b + 4 * S_c + 1
        );
        check_vector_eq!(
            atimesb_vec_12,
            zero_pad!(abnaive_vec_12, 2 * K + 4 * S_a + 4 * S_b + 4 * S_c + 1),
            "The 13'th convolution is incorrect"
        );
        add_expression_vector_to_vector!(
            sum_vec,
            i,
            (linear_combination!(
                E::Fr::zero(),
                power(alpha, 6),
                vector_index!(r_vec_tilde, (i as i64) - (1) as i64 + 1)
            )) * (linear_combination!(linear_combination!(multi_delta!(
                i,
                to_field::<E::Fr>(1),
                K + S_a + S_b + S_c
            ))))
        );
        let abnaive_vec_13 = vector_poly_mul!(
            expression_vector!(
                i,
                linear_combination!(
                    E::Fr::zero(),
                    power(alpha, 6),
                    vector_index!(r_vec_tilde, (i as i64) - (1) as i64 + 1)
                ),
                K + 2 * S_a + 2 * S_b + 2 * S_c + 1
            ),
            expression_vector!(
                i,
                linear_combination!(linear_combination!(multi_delta!(
                    i,
                    to_field::<E::Fr>(1),
                    K + S_a + S_b + S_c
                ))),
                K + 2 * S_a + 2 * S_b + 2 * S_c + 1
            ),
            omega
        );
        add_vector_to_vector!(hcheck_vec, abnaive_vec_13);
        let v_vec_22 = vector_reverse_omega!(r_vec_tilde, omega);
        let shiftlength_9 = r_vec_tilde.len() as i64 - 1;
        // The vector pair here is \alpha^{6}\cdot \tilde{\vec{r}} and \vec{e}_{K + S_{a} + S_{b} + S_{c}}
        let atimesb_vec_13 = expression_vector!(
            i,
            linear_combination!(
                E::Fr::zero(),
                power(alpha, 6),
                vector_index!(
                    v_vec_22,
                    (-K - 2 * S_a - 2 * S_b - 2 * S_c + i as i64)
                        - (K + S_a + S_b + S_c - shiftlength_9) as i64
                        + 1
                )
            ),
            2 * K + 4 * S_a + 4 * S_b + 4 * S_c + 1
        );
        check_vector_eq!(
            atimesb_vec_13,
            zero_pad!(abnaive_vec_13, 2 * K + 4 * S_a + 4 * S_b + 4 * S_c + 1),
            "The 14'th convolution is incorrect"
        );
        add_expression_vector_to_vector!(
            sum_vec,
            i,
            (linear_combination!(linear_combination!(
                E::Fr::zero(),
                -to_field::<E::Fr>(1),
                range_index!(1, S_a + S_b + S_c + 1, i - (K + S_a + S_b + S_c + 1) + 1)
            ))) * (linear_combination!(
                E::Fr::zero(),
                to_field::<E::Fr>(1),
                vector_index!(t_vec_1, (i as i64) - (K + S_a + S_b + S_c) as i64 + 1)
            ))
        );
        let abnaive_vec_14 = vector_poly_mul!(
            expression_vector!(
                i,
                linear_combination!(linear_combination!(
                    E::Fr::zero(),
                    -to_field::<E::Fr>(1),
                    range_index!(1, S_a + S_b + S_c + 1, i - (K + S_a + S_b + S_c + 1) + 1)
                )),
                K + 2 * S_a + 2 * S_b + 2 * S_c + 1
            ),
            expression_vector!(
                i,
                linear_combination!(
                    E::Fr::zero(),
                    to_field::<E::Fr>(1),
                    vector_index!(t_vec_1, (i as i64) - (K + S_a + S_b + S_c) as i64 + 1)
                ),
                K + 2 * S_a + 2 * S_b + 2 * S_c + 1
            ),
            omega
        );
        add_vector_to_vector!(hcheck_vec, abnaive_vec_14);
        let v_vec_23 = vector_power_mul!(t_vec_1, omega.inverse().unwrap(), S_a + S_b + S_c + 1);
        // The vector pair here is -{\vec{1}^{S_{a} + S_{b} + S_{c} + 1}}^{\to K + S_{a} + S_{b} + S_{c}} and {{\vec{t}}_{\mathtt{\text{1}}}}^{\to K + S_{a} + S_{b} + S_{c} - 1}
        let atimesb_vec_14 = expression_vector!(
            i,
            linear_combination!(
                E::Fr::zero(),
                -power(omega, K + 2 * S_a + 2 * S_b + 2 * S_c),
                vector_index!(
                    v_vec_23,
                    (-K - 2 * S_a - 2 * S_b - 2 * S_c + i as i64) - (-S_a - S_b - S_c) as i64 + 1
                )
            ),
            2 * K + 4 * S_a + 4 * S_b + 4 * S_c + 1
        );
        check_vector_eq!(
            atimesb_vec_14,
            zero_pad!(abnaive_vec_14, 2 * K + 4 * S_a + 4 * S_b + 4 * S_c + 1),
            "The 15'th convolution is incorrect"
        );
        let mut h_osum = E::Fr::zero();
        h_osum += eval_vector_expression!(
            omega,
            i,
            (linear_combination!(linear_combination!(
                E::Fr::zero(),
                mu,
                range_index!(1, 3 * H, i - (1) + 1),
                -to_field::<E::Fr>(1),
                power_vector_index!(gamma, 3 * H, i - (1) + 1)
            ))) * (linear_combination!(
                E::Fr::zero(),
                to_field::<E::Fr>(1),
                vector_index!(s_vec, (i as i64) - (1) as i64 + 1)
            )),
            K + 2 * S_a + 2 * S_b + 2 * S_c + 1
        );
        h_osum += eval_vector_expression!(
            omega,
            i,
            (linear_combination!(linear_combination!(
                E::Fr::zero(),
                -to_field::<E::Fr>(1),
                range_index!(1, 3 * H, i - (1) + 1)
            ))) * (linear_combination!(linear_combination!(
                E::Fr::zero(),
                to_field::<E::Fr>(1),
                range_index!(1, 3 * H, i - (1) + 1)
            ))),
            K + 2 * S_a + 2 * S_b + 2 * S_c + 1
        );
        h_osum += eval_vector_expression!(
            omega,
            i,
            (linear_combination!(linear_combination!(
                E::Fr::zero(),
                alpha * nu,
                range_index!(1, K, i - (1) + 1),
                -alpha,
                power_vector_index!(gamma, K, i - (1) + 1)
            ))) * (linear_combination!(
                E::Fr::zero(),
                to_field::<E::Fr>(1),
                vector_index!(h_vec, (i as i64) - (1) as i64 + 1)
            )),
            K + 2 * S_a + 2 * S_b + 2 * S_c + 1
        );
        h_osum += eval_vector_expression!(
            omega,
            i,
            (linear_combination!(linear_combination!(
                E::Fr::zero(),
                -alpha,
                range_index!(1, K, i - (1) + 1)
            ))) * (linear_combination!(linear_combination!(
                E::Fr::zero(),
                to_field::<E::Fr>(1),
                range_index!(1, K, i - (1) + 1)
            ))),
            K + 2 * S_a + 2 * S_b + 2 * S_c + 1
        );
        h_osum += eval_vector_expression!(
            omega,
            i,
            (linear_combination!(
                E::Fr::zero(),
                power(alpha, 2),
                vector_index!(h_vec, (i as i64) - (1) as i64 + 1)
            )) * (linear_combination!(
                linear_combination!(
                    E::Fr::zero(),
                    mu * nu,
                    range_index!(1, S_a + S_b + S_c, i - (K + 1) + 1)
                ),
                -mu,
                vector_index!(pk.w_vec, (i as i64) - (K + 1) as i64 + 1),
                -nu,
                vector_index!(pk.u_vec, (i as i64) - (K + 1) as i64 + 1),
                to_field::<E::Fr>(1),
                vector_index!(pk.y_vec, (i as i64) - (K + 1) as i64 + 1)
            )),
            K + 2 * S_a + 2 * S_b + 2 * S_c + 1
        );
        h_osum += eval_vector_expression!(
            omega,
            i,
            (linear_combination!(linear_combination!(
                E::Fr::zero(),
                -power(alpha, 2),
                range_index!(1, S_a + S_b + S_c, i - (K + 1) + 1)
            ))) * (linear_combination!(linear_combination!(
                E::Fr::zero(),
                to_field::<E::Fr>(1),
                range_index!(1, S_a + S_b + S_c, i - (K + 1) + 1)
            ))),
            K + 2 * S_a + 2 * S_b + 2 * S_c + 1
        );
        h_osum += eval_vector_expression!(
            omega,
            i,
            (linear_combination!(
                E::Fr::zero(),
                power(alpha, 3),
                vector_index!(
                    u_vec_1,
                    (i as i64) - (-H + K + S_a + S_b + S_c + 1) as i64 + 1
                )
            )) * (linear_combination!(
                E::Fr::zero(),
                to_field::<E::Fr>(1),
                vector_index!(
                    u_vec_1,
                    (i as i64) - (-2 * H + K + S_a + S_b + S_c + 1) as i64 + 1
                )
            )),
            K + 2 * S_a + 2 * S_b + 2 * S_c + 1
        );
        h_osum += eval_vector_expression!(
            omega,
            i,
            (linear_combination!(linear_combination!(
                E::Fr::zero(),
                -power(alpha, 3),
                range_index!(1, H, i - (-H + K + S_a + S_b + S_c + 1) + 1)
            ))) * (linear_combination!(
                E::Fr::zero(),
                to_field::<E::Fr>(1),
                vector_index!(
                    u_vec_1,
                    (i as i64) - (-3 * H + K + S_a + S_b + S_c + 1) as i64 + 1
                )
            )),
            K + 2 * S_a + 2 * S_b + 2 * S_c + 1
        );
        h_osum += eval_vector_expression!(
            omega,
            i,
            (linear_combination!(linear_combination!(
                E::Fr::zero(),
                power(alpha, 4),
                range_index!(1, ell + 1, i - (3 * H + 1) + 1)
            ))) * (linear_combination!(
                linear_combination!(multi_delta!(i, -to_field::<E::Fr>(1), 3 * H + 1)),
                to_field::<E::Fr>(1),
                vector_index!(u_vec_1, (i as i64) - (1) as i64 + 1),
                -to_field::<E::Fr>(1),
                vector_index!(x_vec, (i as i64) - (3 * H + 2) as i64 + 1)
            )),
            K + 2 * S_a + 2 * S_b + 2 * S_c + 1
        );
        h_osum += eval_vector_expression!(
            omega,
            i,
            (linear_combination!(
                E::Fr::zero(),
                power(alpha, 5),
                vector_index!(
                    u_vec_1,
                    (i as i64) - (-3 * H + S_a + S_b + S_c + 1) as i64 + 1
                )
            )) * (linear_combination!(
                E::Fr::zero(),
                to_field::<E::Fr>(1),
                vector_index!(
                    s_vec,
                    (i as i64) - (-3 * H + S_a + S_b + S_c + 1) as i64 + 1
                )
            )),
            K + 2 * S_a + 2 * S_b + 2 * S_c + 1
        );
        h_osum += eval_vector_expression!(
            omega,
            i,
            (linear_combination!(
                E::Fr::zero(),
                -power(alpha, 5) * beta,
                vector_index!(h_vec, (i as i64) - (S_a + S_b + S_c + 1) as i64 + 1)
            )) * (linear_combination!(
                E::Fr::zero(),
                to_field::<E::Fr>(1),
                vector_index!(
                    s_vec,
                    (i as i64) - (-3 * H + S_a + S_b + S_c + 1) as i64 + 1
                )
            )),
            K + 2 * S_a + 2 * S_b + 2 * S_c + 1
        );
        h_osum += eval_vector_expression!(
            omega,
            i,
            (linear_combination!(
                E::Fr::zero(),
                -power(alpha, 5) * beta,
                vector_index!(h_vec, (i as i64) - (1) as i64 + 1)
            )) * (linear_combination!(
                E::Fr::zero(),
                to_field::<E::Fr>(1),
                vector_index!(pk.v_vec, (i as i64) - (K + 1) as i64 + 1)
            )),
            K + 2 * S_a + 2 * S_b + 2 * S_c + 1
        );
        h_osum += eval_vector_expression!(
            omega,
            i,
            (linear_combination!(
                E::Fr::zero(),
                -power(alpha, 5),
                vector_index!(r_vec_tilde, (i as i64) - (1) as i64 + 1),
                power(alpha, 5),
                vector_index!(r_vec_tilde, (i as i64) - (2) as i64 + 1)
            )) * (linear_combination!(linear_combination!(
                E::Fr::zero(),
                to_field::<E::Fr>(1),
                range_index!(1, K + S_a + S_b + S_c, i - (1) + 1)
            ))),
            K + 2 * S_a + 2 * S_b + 2 * S_c + 1
        );
        h_osum += eval_vector_expression!(
            omega,
            i,
            (linear_combination!(
                E::Fr::zero(),
                power(alpha, 6),
                vector_index!(r_vec_tilde, (i as i64) - (1) as i64 + 1)
            )) * (linear_combination!(linear_combination!(multi_delta!(
                i,
                to_field::<E::Fr>(1),
                K + S_a + S_b + S_c
            )))),
            K + 2 * S_a + 2 * S_b + 2 * S_c + 1
        );
        h_osum += eval_vector_expression!(
            omega,
            i,
            (linear_combination!(linear_combination!(
                E::Fr::zero(),
                -to_field::<E::Fr>(1),
                range_index!(1, S_a + S_b + S_c + 1, i - (K + S_a + S_b + S_c + 1) + 1)
            ))) * (linear_combination!(
                E::Fr::zero(),
                to_field::<E::Fr>(1),
                vector_index!(t_vec_1, (i as i64) - (K + S_a + S_b + S_c) as i64 + 1)
            )),
            K + 2 * S_a + 2 * S_b + 2 * S_c + 1
        );
        assert_eq!(h_osum, E::Fr::zero());
        check_vector_eq!(
            sum_vec,
            vec!(E::Fr::zero(); (K + 2 * S_a + 2 * S_b + 2 * S_c + 1) as usize),
            "sum of hadamards not zero"
        );
        let v_vec_24 = vector_poly_mul!(h_vec, pk.w_vec, omega).coeffs;
        let shiftlength_10 = h_vec.len() as i64 - 1;
        let v_vec_25 = vector_reverse_omega!(h_vec, omega);
        let shiftlength_11 = h_vec.len() as i64 - 1;
        let v_vec_26 = vector_poly_mul!(h_vec, pk.u_vec, omega).coeffs;
        let shiftlength_12 = h_vec.len() as i64 - 1;
        let v_vec_27 = vector_poly_mul!(h_vec, pk.y_vec, omega).coeffs;
        let shiftlength_13 = h_vec.len() as i64 - 1;
        let v_vec_28 = vector_poly_mul!(u_vec_1, u_vec_1, omega).coeffs;
        let shiftlength_14 = u_vec_1.len() as i64 - 1;
        let v_vec_29 = vector_poly_mul!(u_vec_1, s_vec, omega).coeffs;
        let shiftlength_15 = u_vec_1.len() as i64 - 1;
        let v_vec_30 = vector_poly_mul!(h_vec, s_vec, omega).coeffs;
        let shiftlength_16 = h_vec.len() as i64 - 1;
        let v_vec_31 = vector_poly_mul!(h_vec, pk.v_vec, omega).coeffs;
        let shiftlength_17 = h_vec.len() as i64 - 1;
        let v_vec_32 = vector_reverse_omega!(r_vec_tilde, omega);
        let shiftlength_18 = r_vec_tilde.len() as i64 - 1;
        let v_vec_33 = vector_power_mul!(s_vec, omega.inverse().unwrap(), 3 * H);
        let v_vec_34 = vector_power_mul!(s_vec, to_field::<E::Fr>(1) / (gamma * omega), 3 * H);
        let v_vec_35 = vector_power_mul!(h_vec, omega.inverse().unwrap(), K);
        let v_vec_36 = vector_power_mul!(h_vec, to_field::<E::Fr>(1) / (gamma * omega), K);
        let v_vec_37 = vector_power_mul!(v_vec_25, to_field::<E::Fr>(1), S_a + S_b + S_c);
        let v_vec_38 = vector_power_mul!(u_vec_1, omega.inverse().unwrap(), H);
        let v_vec_39 = vector_power_mul!(u_vec_1, omega.inverse().unwrap(), ell + 1);
        let v_vec_40 = vector_power_mul!(x_vec, omega.inverse().unwrap(), ell + 1);
        let v_vec_41 = vector_power_mul!(v_vec_32, to_field::<E::Fr>(1), K + S_a + S_b + S_c);
        let v_vec_42 = vector_power_mul!(t_vec_1, omega.inverse().unwrap(), S_a + S_b + S_c + 1);
        let v_vec_43 =
            power_power_mul!(omega.inverse().unwrap(), 3 * H, to_field::<E::Fr>(1), 3 * H);
        let v_vec_44 = power_power_mul!(omega.inverse().unwrap(), K, to_field::<E::Fr>(1), K);
        let v_vec_45 = power_power_mul!(
            omega.inverse().unwrap(),
            S_a + S_b + S_c,
            to_field::<E::Fr>(1),
            S_a + S_b + S_c
        );
        let h_vec_2 = expression_vector!(
            i,
            linear_combination!(
                linear_combination!(
                    E::Fr::zero(),
                    -power(alpha, 4) * power(omega, 3 * H + ell),
                    power_vector_index!(
                        omega.inverse().unwrap(),
                        ell + 1,
                        -K - 2 * S_a - 2 * S_b - 2 * S_c + i - (1 - ell) + 1
                    )
                ),
                -power(alpha, 2) * mu,
                vector_index!(
                    v_vec_24,
                    (-K - 2 * S_a - 2 * S_b - 2 * S_c + i as i64) - (K - shiftlength_10 + 1) as i64
                        + 1
                ),
                -power(alpha, 2) * nu,
                vector_index!(
                    v_vec_26,
                    (-K - 2 * S_a - 2 * S_b - 2 * S_c + i as i64) - (K - shiftlength_12 + 1) as i64
                        + 1
                ),
                power(alpha, 2),
                vector_index!(
                    v_vec_27,
                    (-K - 2 * S_a - 2 * S_b - 2 * S_c + i as i64) - (K - shiftlength_13 + 1) as i64
                        + 1
                ),
                power(alpha, 3) * power(omega, -H + K + S_a + S_b + S_c),
                vector_index!(
                    v_vec_28,
                    (-K - 2 * S_a - 2 * S_b - 2 * S_c + i as i64)
                        - (-H - shiftlength_14 + 1) as i64
                        + 1
                ),
                power(alpha, 5) * power(omega, -3 * H + S_a + S_b + S_c),
                vector_index!(
                    v_vec_29,
                    (-K - 2 * S_a - 2 * S_b - 2 * S_c + i as i64) - (1 - shiftlength_15) as i64 + 1
                ),
                -power(alpha, 5) * beta * power(omega, S_a + S_b + S_c),
                vector_index!(
                    v_vec_30,
                    (-K - 2 * S_a - 2 * S_b - 2 * S_c + i as i64)
                        - (-3 * H - shiftlength_16 + 1) as i64
                        + 1
                ),
                -power(alpha, 5) * beta,
                vector_index!(
                    v_vec_31,
                    (-K - 2 * S_a - 2 * S_b - 2 * S_c + i as i64) - (K - shiftlength_17 + 1) as i64
                        + 1
                ),
                power(alpha, 6),
                vector_index!(
                    v_vec_32,
                    (-K - 2 * S_a - 2 * S_b - 2 * S_c + i as i64)
                        - (K + S_a + S_b + S_c - shiftlength_18) as i64
                        + 1
                ),
                mu * power(omega, 3 * H - 1),
                vector_index!(
                    v_vec_33,
                    (-K - 2 * S_a - 2 * S_b - 2 * S_c + i as i64) - (2 - 3 * H) as i64 + 1
                ),
                -power(gamma * omega, 3 * H - 1),
                vector_index!(
                    v_vec_34,
                    (-K - 2 * S_a - 2 * S_b - 2 * S_c + i as i64) - (2 - 3 * H) as i64 + 1
                ),
                alpha * nu * power(omega, K - 1),
                vector_index!(
                    v_vec_35,
                    (-K - 2 * S_a - 2 * S_b - 2 * S_c + i as i64) - (2 - K) as i64 + 1
                ),
                -alpha * power(gamma * omega, K - 1),
                vector_index!(
                    v_vec_36,
                    (-K - 2 * S_a - 2 * S_b - 2 * S_c + i as i64) - (2 - K) as i64 + 1
                ),
                power(alpha, 2) * mu * nu,
                vector_index!(
                    v_vec_37,
                    (-K - 2 * S_a - 2 * S_b - 2 * S_c + i as i64) - (K - shiftlength_11 + 1) as i64
                        + 1
                ),
                -power(alpha, 3) * power(omega, K + S_a + S_b + S_c - 1),
                vector_index!(
                    v_vec_38,
                    (-K - 2 * S_a - 2 * S_b - 2 * S_c + i as i64) - (2 - 3 * H) as i64 + 1
                ),
                power(alpha, 4) * power(omega, 3 * H + ell),
                vector_index!(
                    v_vec_39,
                    (-K - 2 * S_a - 2 * S_b - 2 * S_c + i as i64) - (-3 * H - ell + 1) as i64 + 1
                ),
                -power(alpha, 4) * power(omega, 3 * H + ell),
                vector_index!(
                    v_vec_40,
                    (-K - 2 * S_a - 2 * S_b - 2 * S_c + i as i64) - (2 - ell) as i64 + 1
                ),
                -power(alpha, 5),
                vector_index!(
                    v_vec_41,
                    (-K - 2 * S_a - 2 * S_b - 2 * S_c + i as i64) - (1 - shiftlength_18) as i64 + 1
                ),
                power(alpha, 5) * omega,
                vector_index!(
                    v_vec_41,
                    (-K - 2 * S_a - 2 * S_b - 2 * S_c + i as i64) - (-shiftlength_18) as i64 + 1
                ),
                -power(omega, K + 2 * S_a + 2 * S_b + 2 * S_c),
                vector_index!(
                    v_vec_42,
                    (-K - 2 * S_a - 2 * S_b - 2 * S_c + i as i64) - (-S_a - S_b - S_c) as i64 + 1
                ),
                -power(omega, 3 * H - 1),
                vector_index!(
                    v_vec_43,
                    (-K - 2 * S_a - 2 * S_b - 2 * S_c + i as i64) - (2 - 3 * H) as i64 + 1
                ),
                -alpha * power(omega, K - 1),
                vector_index!(
                    v_vec_44,
                    (-K - 2 * S_a - 2 * S_b - 2 * S_c + i as i64) - (2 - K) as i64 + 1
                ),
                -power(alpha, 2) * power(omega, K + S_a + S_b + S_c - 1),
                vector_index!(
                    v_vec_45,
                    (-K - 2 * S_a - 2 * S_b - 2 * S_c + i as i64) - (-S_a - S_b - S_c + 2) as i64
                        + 1
                )
            ),
            K + 2 * S_a + 2 * S_b + 2 * S_c
        );
        let h_vec_3 = expression_vector!(
            i,
            linear_combination!(
                linear_combination!(
                    E::Fr::zero(),
                    -power(alpha, 4) * power(omega, 3 * H + ell),
                    power_vector_index!(omega.inverse().unwrap(), ell + 1, i + 1 - (1 - ell) + 1)
                ),
                -power(alpha, 2) * mu,
                vector_index!(
                    v_vec_24,
                    (i + 1 as i64) - (K - shiftlength_10 + 1) as i64 + 1
                ),
                -power(alpha, 2) * nu,
                vector_index!(
                    v_vec_26,
                    (i + 1 as i64) - (K - shiftlength_12 + 1) as i64 + 1
                ),
                power(alpha, 2),
                vector_index!(
                    v_vec_27,
                    (i + 1 as i64) - (K - shiftlength_13 + 1) as i64 + 1
                ),
                power(alpha, 3) * power(omega, -H + K + S_a + S_b + S_c),
                vector_index!(
                    v_vec_28,
                    (i + 1 as i64) - (-H - shiftlength_14 + 1) as i64 + 1
                ),
                power(alpha, 5) * power(omega, -3 * H + S_a + S_b + S_c),
                vector_index!(v_vec_29, (i + 1 as i64) - (1 - shiftlength_15) as i64 + 1),
                -power(alpha, 5) * beta * power(omega, S_a + S_b + S_c),
                vector_index!(
                    v_vec_30,
                    (i + 1 as i64) - (-3 * H - shiftlength_16 + 1) as i64 + 1
                ),
                -power(alpha, 5) * beta,
                vector_index!(
                    v_vec_31,
                    (i + 1 as i64) - (K - shiftlength_17 + 1) as i64 + 1
                ),
                power(alpha, 6),
                vector_index!(
                    v_vec_32,
                    (i + 1 as i64) - (K + S_a + S_b + S_c - shiftlength_18) as i64 + 1
                ),
                mu * power(omega, 3 * H - 1),
                vector_index!(v_vec_33, (i + 1 as i64) - (2 - 3 * H) as i64 + 1),
                -power(gamma * omega, 3 * H - 1),
                vector_index!(v_vec_34, (i + 1 as i64) - (2 - 3 * H) as i64 + 1),
                alpha * nu * power(omega, K - 1),
                vector_index!(v_vec_35, (i + 1 as i64) - (2 - K) as i64 + 1),
                -alpha * power(gamma * omega, K - 1),
                vector_index!(v_vec_36, (i + 1 as i64) - (2 - K) as i64 + 1),
                power(alpha, 2) * mu * nu,
                vector_index!(
                    v_vec_37,
                    (i + 1 as i64) - (K - shiftlength_11 + 1) as i64 + 1
                ),
                -power(alpha, 3) * power(omega, K + S_a + S_b + S_c - 1),
                vector_index!(v_vec_38, (i + 1 as i64) - (2 - 3 * H) as i64 + 1),
                power(alpha, 4) * power(omega, 3 * H + ell),
                vector_index!(v_vec_39, (i + 1 as i64) - (-3 * H - ell + 1) as i64 + 1),
                -power(alpha, 4) * power(omega, 3 * H + ell),
                vector_index!(v_vec_40, (i + 1 as i64) - (2 - ell) as i64 + 1),
                -power(alpha, 5),
                vector_index!(v_vec_41, (i + 1 as i64) - (1 - shiftlength_18) as i64 + 1),
                power(alpha, 5) * omega,
                vector_index!(v_vec_41, (i + 1 as i64) - (-shiftlength_18) as i64 + 1),
                -power(omega, K + 2 * S_a + 2 * S_b + 2 * S_c),
                vector_index!(v_vec_42, (i + 1 as i64) - (-S_a - S_b - S_c) as i64 + 1),
                -power(omega, 3 * H - 1),
                vector_index!(v_vec_43, (i + 1 as i64) - (2 - 3 * H) as i64 + 1),
                -alpha * power(omega, K - 1),
                vector_index!(v_vec_44, (i + 1 as i64) - (2 - K) as i64 + 1),
                -power(alpha, 2) * power(omega, K + S_a + S_b + S_c - 1),
                vector_index!(v_vec_45, (i + 1 as i64) - (-S_a - S_b - S_c + 2) as i64 + 1)
            ),
            K + 2 * S_a + 2 * S_b + 2 * S_c
        );
        let h_vec_1 = expression_vector!(
            i,
            linear_combination!(
                linear_combination!(
                    E::Fr::zero(),
                    -power(alpha, 4) * power(omega, 3 * H + ell),
                    power_vector_index!(
                        omega.inverse().unwrap(),
                        ell + 1,
                        -K - 2 * S_a - 2 * S_b - 2 * S_c + i - (1 - ell) + 1
                    )
                ),
                -power(alpha, 2) * mu,
                vector_index!(
                    v_vec_24,
                    (-K - 2 * S_a - 2 * S_b - 2 * S_c + i as i64) - (K - shiftlength_10 + 1) as i64
                        + 1
                ),
                -power(alpha, 2) * nu,
                vector_index!(
                    v_vec_26,
                    (-K - 2 * S_a - 2 * S_b - 2 * S_c + i as i64) - (K - shiftlength_12 + 1) as i64
                        + 1
                ),
                power(alpha, 2),
                vector_index!(
                    v_vec_27,
                    (-K - 2 * S_a - 2 * S_b - 2 * S_c + i as i64) - (K - shiftlength_13 + 1) as i64
                        + 1
                ),
                power(alpha, 3) * power(omega, -H + K + S_a + S_b + S_c),
                vector_index!(
                    v_vec_28,
                    (-K - 2 * S_a - 2 * S_b - 2 * S_c + i as i64)
                        - (-H - shiftlength_14 + 1) as i64
                        + 1
                ),
                power(alpha, 5) * power(omega, -3 * H + S_a + S_b + S_c),
                vector_index!(
                    v_vec_29,
                    (-K - 2 * S_a - 2 * S_b - 2 * S_c + i as i64) - (1 - shiftlength_15) as i64 + 1
                ),
                -power(alpha, 5) * beta * power(omega, S_a + S_b + S_c),
                vector_index!(
                    v_vec_30,
                    (-K - 2 * S_a - 2 * S_b - 2 * S_c + i as i64)
                        - (-3 * H - shiftlength_16 + 1) as i64
                        + 1
                ),
                -power(alpha, 5) * beta,
                vector_index!(
                    v_vec_31,
                    (-K - 2 * S_a - 2 * S_b - 2 * S_c + i as i64) - (K - shiftlength_17 + 1) as i64
                        + 1
                ),
                power(alpha, 6),
                vector_index!(
                    v_vec_32,
                    (-K - 2 * S_a - 2 * S_b - 2 * S_c + i as i64)
                        - (K + S_a + S_b + S_c - shiftlength_18) as i64
                        + 1
                ),
                mu * power(omega, 3 * H - 1),
                vector_index!(
                    v_vec_33,
                    (-K - 2 * S_a - 2 * S_b - 2 * S_c + i as i64) - (2 - 3 * H) as i64 + 1
                ),
                -power(gamma * omega, 3 * H - 1),
                vector_index!(
                    v_vec_34,
                    (-K - 2 * S_a - 2 * S_b - 2 * S_c + i as i64) - (2 - 3 * H) as i64 + 1
                ),
                alpha * nu * power(omega, K - 1),
                vector_index!(
                    v_vec_35,
                    (-K - 2 * S_a - 2 * S_b - 2 * S_c + i as i64) - (2 - K) as i64 + 1
                ),
                -alpha * power(gamma * omega, K - 1),
                vector_index!(
                    v_vec_36,
                    (-K - 2 * S_a - 2 * S_b - 2 * S_c + i as i64) - (2 - K) as i64 + 1
                ),
                power(alpha, 2) * mu * nu,
                vector_index!(
                    v_vec_37,
                    (-K - 2 * S_a - 2 * S_b - 2 * S_c + i as i64) - (K - shiftlength_11 + 1) as i64
                        + 1
                ),
                -power(alpha, 3) * power(omega, K + S_a + S_b + S_c - 1),
                vector_index!(
                    v_vec_38,
                    (-K - 2 * S_a - 2 * S_b - 2 * S_c + i as i64) - (2 - 3 * H) as i64 + 1
                ),
                power(alpha, 4) * power(omega, 3 * H + ell),
                vector_index!(
                    v_vec_39,
                    (-K - 2 * S_a - 2 * S_b - 2 * S_c + i as i64) - (-3 * H - ell + 1) as i64 + 1
                ),
                -power(alpha, 4) * power(omega, 3 * H + ell),
                vector_index!(
                    v_vec_40,
                    (-K - 2 * S_a - 2 * S_b - 2 * S_c + i as i64) - (2 - ell) as i64 + 1
                ),
                -power(alpha, 5),
                vector_index!(
                    v_vec_41,
                    (-K - 2 * S_a - 2 * S_b - 2 * S_c + i as i64) - (1 - shiftlength_18) as i64 + 1
                ),
                power(alpha, 5) * omega,
                vector_index!(
                    v_vec_41,
                    (-K - 2 * S_a - 2 * S_b - 2 * S_c + i as i64) - (-shiftlength_18) as i64 + 1
                ),
                -power(omega, K + 2 * S_a + 2 * S_b + 2 * S_c),
                vector_index!(
                    v_vec_42,
                    (-K - 2 * S_a - 2 * S_b - 2 * S_c + i as i64) - (-S_a - S_b - S_c) as i64 + 1
                ),
                -power(omega, 3 * H - 1),
                vector_index!(
                    v_vec_43,
                    (-K - 2 * S_a - 2 * S_b - 2 * S_c + i as i64) - (2 - 3 * H) as i64 + 1
                ),
                -alpha * power(omega, K - 1),
                vector_index!(
                    v_vec_44,
                    (-K - 2 * S_a - 2 * S_b - 2 * S_c + i as i64) - (2 - K) as i64 + 1
                ),
                -power(alpha, 2) * power(omega, K + S_a + S_b + S_c - 1),
                vector_index!(
                    v_vec_45,
                    (-K - 2 * S_a - 2 * S_b - 2 * S_c + i as i64) - (-S_a - S_b - S_c + 2) as i64
                        + 1
                )
            ),
            2 * K + 4 * S_a + 4 * S_b + 4 * S_c + 1
        );
        check_vector_eq!(h_vec_1, hcheck_vec, "h is not expected");
        check_vector_eq!(
            h_vec_1,
            vector_concat!(h_vec_2, vec!(E::Fr::zero()), h_vec_3),
            "h != h1 || 0 || h2"
        );
        assert_eq!(
            linear_combination!(
                linear_combination!(
                    E::Fr::zero(),
                    -power(alpha, 4) * power(omega, 3 * H + ell),
                    power_vector_index!(omega.inverse().unwrap(), ell + 1, 1 - (1 - ell) + 1)
                ),
                -power(alpha, 2) * mu,
                vector_index!(v_vec_24, (1 as i64) - (K - shiftlength_10 + 1) as i64 + 1),
                -power(alpha, 2) * nu,
                vector_index!(v_vec_26, (1 as i64) - (K - shiftlength_12 + 1) as i64 + 1),
                power(alpha, 2),
                vector_index!(v_vec_27, (1 as i64) - (K - shiftlength_13 + 1) as i64 + 1),
                power(alpha, 3) * power(omega, -H + K + S_a + S_b + S_c),
                vector_index!(v_vec_28, (1 as i64) - (-H - shiftlength_14 + 1) as i64 + 1),
                power(alpha, 5) * power(omega, -3 * H + S_a + S_b + S_c),
                vector_index!(v_vec_29, (1 as i64) - (1 - shiftlength_15) as i64 + 1),
                -power(alpha, 5) * beta * power(omega, S_a + S_b + S_c),
                vector_index!(
                    v_vec_30,
                    (1 as i64) - (-3 * H - shiftlength_16 + 1) as i64 + 1
                ),
                -power(alpha, 5) * beta,
                vector_index!(v_vec_31, (1 as i64) - (K - shiftlength_17 + 1) as i64 + 1),
                power(alpha, 6),
                vector_index!(
                    v_vec_32,
                    (1 as i64) - (K + S_a + S_b + S_c - shiftlength_18) as i64 + 1
                ),
                mu * power(omega, 3 * H - 1),
                vector_index!(v_vec_33, (1 as i64) - (2 - 3 * H) as i64 + 1),
                -power(gamma * omega, 3 * H - 1),
                vector_index!(v_vec_34, (1 as i64) - (2 - 3 * H) as i64 + 1),
                alpha * nu * power(omega, K - 1),
                vector_index!(v_vec_35, (1 as i64) - (2 - K) as i64 + 1),
                -alpha * power(gamma * omega, K - 1),
                vector_index!(v_vec_36, (1 as i64) - (2 - K) as i64 + 1),
                power(alpha, 2) * mu * nu,
                vector_index!(v_vec_37, (1 as i64) - (K - shiftlength_11 + 1) as i64 + 1),
                -power(alpha, 3) * power(omega, K + S_a + S_b + S_c - 1),
                vector_index!(v_vec_38, (1 as i64) - (2 - 3 * H) as i64 + 1),
                power(alpha, 4) * power(omega, 3 * H + ell),
                vector_index!(v_vec_39, (1 as i64) - (-3 * H - ell + 1) as i64 + 1),
                -power(alpha, 4) * power(omega, 3 * H + ell),
                vector_index!(v_vec_40, (1 as i64) - (2 - ell) as i64 + 1),
                -power(alpha, 5),
                vector_index!(v_vec_41, (1 as i64) - (1 - shiftlength_18) as i64 + 1),
                power(alpha, 5) * omega,
                vector_index!(v_vec_41, (1 as i64) - (-shiftlength_18) as i64 + 1),
                -power(omega, K + 2 * S_a + 2 * S_b + 2 * S_c),
                vector_index!(v_vec_42, (1 as i64) - (-S_a - S_b - S_c) as i64 + 1),
                -power(omega, 3 * H - 1),
                vector_index!(v_vec_43, (1 as i64) - (2 - 3 * H) as i64 + 1),
                -alpha * power(omega, K - 1),
                vector_index!(v_vec_44, (1 as i64) - (2 - K) as i64 + 1),
                -power(alpha, 2) * power(omega, K + S_a + S_b + S_c - 1),
                vector_index!(v_vec_45, (1 as i64) - (-S_a - S_b - S_c + 2) as i64 + 1)
            ),
            E::Fr::zero()
        );
        let cm_h_vec_2 = vector_to_commitment::<E>(&pk.powers, &h_vec_2).unwrap();
        let cm_h_vec_3 = vector_to_commitment::<E>(&pk.powers, &h_vec_3).unwrap();
        let z = hash_to_field::<E::Fr>(
            to_bytes!(
                x_vec,
                pk.verifier_key.cm_u_vec,
                pk.verifier_key.cm_w_vec,
                pk.verifier_key.cm_v_vec,
                pk.verifier_key.cm_y_vec,
                cm_u_vec_1,
                cm_s_vec,
                cm_h_vec,
                cm_r_vec_tilde,
                cm_t_vec_1,
                cm_h_vec_2,
                cm_h_vec_3
            )
            .unwrap(),
        );
        let y = eval_vector_expression!(
            omega / z,
            i,
            vector_index!(h_vec, i),
            K + S_a + S_b + S_c + 1
        );
        let y_1 = eval_vector_expression!(
            omega / z,
            i,
            vector_index!(u_vec_1, i),
            K + S_a + S_b + S_c + 1
        );
        let y_2 = eval_vector_expression!(
            omega / z,
            i,
            vector_index!(r_vec_tilde, i),
            K + S_a + S_b + S_c + 1
        );
        let c = sum!(
            z * (mu
                * (E::Fr::one() - power(omega / z, 3 * H))
                * (E::Fr::one() * z - gamma * omega)
                - (E::Fr::one() - power(gamma * omega / z, 3 * H)) * (E::Fr::one() * z - omega))
                / ((E::Fr::one() * z - omega) * (E::Fr::one() * z - gamma * omega)),
            power(alpha, 5)
                * y_1
                * power(z, -3 * H + S_a + S_b + S_c)
                * power(omega / z, -3 * H + S_a + S_b + S_c),
            -power(alpha, 5)
                * beta
                * y
                * power(z, -3 * H + S_a + S_b + S_c)
                * power(omega / z, S_a + S_b + S_c)
        );
        let c_1 = sum!(
            -z * (E::Fr::one() - power(z, 3 * H)) * (E::Fr::one() - power(omega / z, 3 * H))
                / ((E::Fr::one() - z) * (E::Fr::one() * z - omega)),
            -alpha * z * (E::Fr::one() - power(z, K)) * (E::Fr::one() - power(omega / z, K))
                / ((E::Fr::one() - z) * (E::Fr::one() * z - omega)),
            power(alpha, 2)
                * mu
                * nu
                * y
                * power(z, K)
                * (E::Fr::one() - power(z, S_a + S_b + S_c))
                / (E::Fr::one() - z),
            -power(alpha, 2)
                * power(z, K + 1)
                * power(omega / z, K)
                * (E::Fr::one() - power(z, S_a + S_b + S_c))
                * (E::Fr::one() - power(omega / z, S_a + S_b + S_c))
                / ((E::Fr::one() - z) * (E::Fr::one() * z - omega)),
            (power(alpha, 4)
                * power(z, 3 * H + 2)
                * power(omega / z, 3 * H)
                * (-E::Fr::one() + power(omega / z, ell + 1))
                / (E::Fr::one() * z - omega))
                * (eval_vector_expression!(z, i, vector_index!(x_vec, i), ell)),
            power(alpha, 4)
                * power(z, 3 * H + 1)
                * power(omega / z, 3 * H)
                * (-E::Fr::one() + power(omega / z, ell + 1))
                / (E::Fr::one() * z - omega),
            power(alpha, 5) * y_2 * (E::Fr::one() - power(z, K + S_a + S_b + S_c)) * (omega - z)
                / (z * (E::Fr::one() - z)),
            power(alpha, 6) * y_2 * power(z, K + S_a + S_b + S_c - 1)
        );
        let c_2 = alpha
            * z
            * (nu * (E::Fr::one() - power(omega / z, K)) * (E::Fr::one() * z - gamma * omega)
                - (E::Fr::one() - power(gamma * omega / z, K)) * (E::Fr::one() * z - omega))
            / ((E::Fr::one() * z - omega) * (E::Fr::one() * z - gamma * omega));
        let c_3 = -power(alpha, 2) * mu * y * power(z, K);
        let c_4 = -power(alpha, 2) * nu * y * power(z, K);
        let c_5 = power(alpha, 2) * y * power(z, K);
        let c_6 = sum!(
            power(alpha, 3)
                * y_1
                * power(z, -2 * H + K + S_a + S_b + S_c)
                * power(omega / z, -H + K + S_a + S_b + S_c),
            power(alpha, 3)
                * power(z, -3 * H + K + S_a + S_b + S_c + 1)
                * power(omega / z, -H + K + S_a + S_b + S_c)
                * (-E::Fr::one() + power(omega / z, H))
                / (E::Fr::one() * z - omega),
            power(alpha, 4)
                * z
                * power(omega / z, 3 * H)
                * (E::Fr::one() - power(omega / z, ell + 1))
                / (E::Fr::one() * z - omega)
        );
        let c_7 = -power(alpha, 5) * beta * y * power(z, K);
        let c_8 = power(z, K + S_a + S_b + S_c)
            * power(omega / z, K + S_a + S_b + S_c)
            * (-E::Fr::one() + power(omega / z, S_a + S_b + S_c + 1))
            / (E::Fr::one() * z - omega);
        let c_9 = -power(z, D);
        let c_10 = -z;
        let mut g_poly = expression_vector!(
            i,
            sum!(
                (c) * (vector_index!(s_vec, i)),
                (c_2) * (vector_index!(h_vec, i)),
                (c_3) * (vector_index!(pk.w_vec, i)),
                (c_4) * (vector_index!(pk.u_vec, i)),
                (c_5) * (vector_index!(pk.y_vec, i)),
                (c_6) * (vector_index!(u_vec_1, i)),
                (c_7) * (vector_index!(pk.v_vec, i)),
                (c_8) * (vector_index!(t_vec_1, i)),
                (c_9) * (vector_index!(h_vec_2, i)),
                (c_10) * (vector_index!(h_vec_3, i))
            ),
            K + S_a + S_b + S_c + 1
        );
        g_poly[0] += c_1;
        let g_poly = poly_from_vec!(g_poly);
        let cm_g = Commitment::<E>(
            sum!(
                (cm_s_vec.0).mul(c.into_repr()),
                (cm_h_vec.0).mul(c_2.into_repr()),
                (vk.cm_w_vec.0).mul(c_3.into_repr()),
                (vk.cm_u_vec.0).mul(c_4.into_repr()),
                (vk.cm_y_vec.0).mul(c_5.into_repr()),
                (cm_u_vec_1.0).mul(c_6.into_repr()),
                (vk.cm_v_vec.0).mul(c_7.into_repr()),
                (cm_t_vec_1.0).mul(c_8.into_repr()),
                (cm_h_vec_2.0).mul(c_9.into_repr()),
                (cm_h_vec_3.0).mul(c_10.into_repr()),
                scalar_to_commitment::<E>(&vk.kzg_vk.g, &c_10)
                    .unwrap()
                    .0
                    .into_projective()
            )
            .into_affine(),
        );
        check_poly_eval!(g_poly, z, E::Fr::zero());
        let fs = vec![h_vec_poly, u_vec_1_poly, r_vec_tilde_poly];
        let gs = vec![g_poly];
        let zz = z;
        let z = omega / z;
        let rand_xi = hash_to_field::<E::Fr>(
            to_bytes!(
                x_vec,
                pk.verifier_key.cm_u_vec,
                pk.verifier_key.cm_w_vec,
                pk.verifier_key.cm_v_vec,
                pk.verifier_key.cm_y_vec,
                cm_u_vec_1,
                cm_s_vec,
                cm_h_vec,
                cm_r_vec_tilde,
                cm_t_vec_1,
                cm_h_vec_2,
                cm_h_vec_3,
                cm_g,
                omega / z,
                y,
                y_1,
                y_2,
                z
            )
            .unwrap(),
        );
        let rand_xi_2 = hash_to_field::<E::Fr>(
            to_bytes!(
                x_vec,
                pk.verifier_key.cm_u_vec,
                pk.verifier_key.cm_w_vec,
                pk.verifier_key.cm_v_vec,
                pk.verifier_key.cm_y_vec,
                cm_u_vec_1,
                cm_s_vec,
                cm_h_vec,
                cm_r_vec_tilde,
                cm_t_vec_1,
                cm_h_vec_2,
                cm_h_vec_3,
                cm_g,
                omega / z,
                y,
                y_1,
                y_2,
                z
            )
            .unwrap(),
        );

        let (W, W_1) = KZG10::batch_open(&pk.powers, &fs, &gs, &z, &zz, &rand_xi, &rand_xi_2)?;
        Ok(R1CSProof::<E> {
            cm_u_vec_1: cm_u_vec_1,
            cm_s_vec: cm_s_vec,
            cm_h_vec: cm_h_vec,
            cm_r_vec_tilde: cm_r_vec_tilde,
            cm_t_vec_1: cm_t_vec_1,
            cm_h_vec_2: cm_h_vec_2,
            cm_h_vec_3: cm_h_vec_3,
            y: y,
            y_1: y_1,
            y_2: y_2,
            W: W,
            W_1: W_1,
        })
    }
    fn verify(vk: &Self::VK, x: &Self::Ins, proof: &Self::Pf) -> Result<(), Error> {
        let size = vk.size.clone();
        let D = vk.D as i64;
        let rng = &mut test_rng();
        let cm_u_vec_1 = proof.cm_u_vec_1;
        let cm_s_vec = proof.cm_s_vec;
        let cm_h_vec = proof.cm_h_vec;
        let cm_r_vec_tilde = proof.cm_r_vec_tilde;
        let cm_t_vec_1 = proof.cm_t_vec_1;
        let cm_h_vec_2 = proof.cm_h_vec_2;
        let cm_h_vec_3 = proof.cm_h_vec_3;
        let y = proof.y;
        let y_1 = proof.y_1;
        let y_2 = proof.y_2;
        let W = proof.W;
        let W_1 = proof.W_1;
        let H = size.nrows as i64;
        let K = size.ncols as i64;
        let S_a = size.adensity as i64;
        let S_b = size.bdensity as i64;
        let S_c = size.cdensity as i64;
        let ell = size.input_size as i64;
        let gamma = generator_of!(E);
        let x_vec = x.instance.clone();
        let mu = hash_to_field::<E::Fr>(
            to_bytes!(
                x_vec,
                vk.cm_u_vec,
                vk.cm_w_vec,
                vk.cm_v_vec,
                vk.cm_y_vec,
                cm_u_vec_1
            )
            .unwrap(),
        );
        let nu = hash_to_field::<E::Fr>(
            to_bytes!(
                x_vec,
                vk.cm_u_vec,
                vk.cm_w_vec,
                vk.cm_v_vec,
                vk.cm_y_vec,
                cm_u_vec_1,
                cm_s_vec
            )
            .unwrap(),
        );
        let beta = hash_to_field::<E::Fr>(
            to_bytes!(
                x_vec,
                vk.cm_u_vec,
                vk.cm_w_vec,
                vk.cm_v_vec,
                vk.cm_y_vec,
                cm_u_vec_1,
                cm_s_vec,
                cm_h_vec
            )
            .unwrap(),
        );
        let alpha = hash_to_field::<E::Fr>(
            to_bytes!(
                x_vec,
                vk.cm_u_vec,
                vk.cm_w_vec,
                vk.cm_v_vec,
                vk.cm_y_vec,
                cm_u_vec_1,
                cm_s_vec,
                cm_h_vec,
                cm_r_vec_tilde
            )
            .unwrap(),
        );
        let omega = hash_to_field::<E::Fr>(
            to_bytes!(
                x_vec,
                vk.cm_u_vec,
                vk.cm_w_vec,
                vk.cm_v_vec,
                vk.cm_y_vec,
                cm_u_vec_1,
                cm_s_vec,
                cm_h_vec,
                cm_r_vec_tilde,
                cm_t_vec_1
            )
            .unwrap(),
        );
        let z = hash_to_field::<E::Fr>(
            to_bytes!(
                x_vec,
                vk.cm_u_vec,
                vk.cm_w_vec,
                vk.cm_v_vec,
                vk.cm_y_vec,
                cm_u_vec_1,
                cm_s_vec,
                cm_h_vec,
                cm_r_vec_tilde,
                cm_t_vec_1,
                cm_h_vec_2,
                cm_h_vec_3
            )
            .unwrap(),
        );
        let c = sum!(
            z * (mu
                * (E::Fr::one() - power(omega / z, 3 * H))
                * (E::Fr::one() * z - gamma * omega)
                - (E::Fr::one() - power(gamma * omega / z, 3 * H)) * (E::Fr::one() * z - omega))
                / ((E::Fr::one() * z - omega) * (E::Fr::one() * z - gamma * omega)),
            power(alpha, 5)
                * y_1
                * power(z, -3 * H + S_a + S_b + S_c)
                * power(omega / z, -3 * H + S_a + S_b + S_c),
            -power(alpha, 5)
                * beta
                * y
                * power(z, -3 * H + S_a + S_b + S_c)
                * power(omega / z, S_a + S_b + S_c)
        );
        let c_1 = sum!(
            -z * (E::Fr::one() - power(z, 3 * H)) * (E::Fr::one() - power(omega / z, 3 * H))
                / ((E::Fr::one() - z) * (E::Fr::one() * z - omega)),
            -alpha * z * (E::Fr::one() - power(z, K)) * (E::Fr::one() - power(omega / z, K))
                / ((E::Fr::one() - z) * (E::Fr::one() * z - omega)),
            power(alpha, 2)
                * mu
                * nu
                * y
                * power(z, K)
                * (E::Fr::one() - power(z, S_a + S_b + S_c))
                / (E::Fr::one() - z),
            -power(alpha, 2)
                * power(z, K + 1)
                * power(omega / z, K)
                * (E::Fr::one() - power(z, S_a + S_b + S_c))
                * (E::Fr::one() - power(omega / z, S_a + S_b + S_c))
                / ((E::Fr::one() - z) * (E::Fr::one() * z - omega)),
            (power(alpha, 4)
                * power(z, 3 * H + 2)
                * power(omega / z, 3 * H)
                * (-E::Fr::one() + power(omega / z, ell + 1))
                / (E::Fr::one() * z - omega))
                * (eval_vector_expression!(z, i, vector_index!(x_vec, i), ell)),
            power(alpha, 4)
                * power(z, 3 * H + 1)
                * power(omega / z, 3 * H)
                * (-E::Fr::one() + power(omega / z, ell + 1))
                / (E::Fr::one() * z - omega),
            power(alpha, 5) * y_2 * (E::Fr::one() - power(z, K + S_a + S_b + S_c)) * (omega - z)
                / (z * (E::Fr::one() - z)),
            power(alpha, 6) * y_2 * power(z, K + S_a + S_b + S_c - 1)
        );
        let c_2 = alpha
            * z
            * (nu * (E::Fr::one() - power(omega / z, K)) * (E::Fr::one() * z - gamma * omega)
                - (E::Fr::one() - power(gamma * omega / z, K)) * (E::Fr::one() * z - omega))
            / ((E::Fr::one() * z - omega) * (E::Fr::one() * z - gamma * omega));
        let c_3 = -power(alpha, 2) * mu * y * power(z, K);
        let c_4 = -power(alpha, 2) * nu * y * power(z, K);
        let c_5 = power(alpha, 2) * y * power(z, K);
        let c_6 = sum!(
            power(alpha, 3)
                * y_1
                * power(z, -2 * H + K + S_a + S_b + S_c)
                * power(omega / z, -H + K + S_a + S_b + S_c),
            power(alpha, 3)
                * power(z, -3 * H + K + S_a + S_b + S_c + 1)
                * power(omega / z, -H + K + S_a + S_b + S_c)
                * (-E::Fr::one() + power(omega / z, H))
                / (E::Fr::one() * z - omega),
            power(alpha, 4)
                * z
                * power(omega / z, 3 * H)
                * (E::Fr::one() - power(omega / z, ell + 1))
                / (E::Fr::one() * z - omega)
        );
        let c_7 = -power(alpha, 5) * beta * y * power(z, K);
        let c_8 = power(z, K + S_a + S_b + S_c)
            * power(omega / z, K + S_a + S_b + S_c)
            * (-E::Fr::one() + power(omega / z, S_a + S_b + S_c + 1))
            / (E::Fr::one() * z - omega);
        let c_9 = -power(z, D);
        let c_10 = -z;
        let cm_g = Commitment::<E>(
            sum!(
                (cm_s_vec.0).mul(c.into_repr()),
                (cm_h_vec.0).mul(c_2.into_repr()),
                (vk.cm_w_vec.0).mul(c_3.into_repr()),
                (vk.cm_u_vec.0).mul(c_4.into_repr()),
                (vk.cm_y_vec.0).mul(c_5.into_repr()),
                (cm_u_vec_1.0).mul(c_6.into_repr()),
                (vk.cm_v_vec.0).mul(c_7.into_repr()),
                (cm_t_vec_1.0).mul(c_8.into_repr()),
                (cm_h_vec_2.0).mul(c_9.into_repr()),
                (cm_h_vec_3.0).mul(c_10.into_repr()),
                scalar_to_commitment::<E>(&vk.kzg_vk.g, &c_10)
                    .unwrap()
                    .0
                    .into_projective()
            )
            .into_affine(),
        );
        let rand_xi = hash_to_field::<E::Fr>(
            to_bytes!(
                x_vec,
                vk.cm_u_vec,
                vk.cm_w_vec,
                vk.cm_v_vec,
                vk.cm_y_vec,
                cm_u_vec_1,
                cm_s_vec,
                cm_h_vec,
                cm_r_vec_tilde,
                cm_t_vec_1,
                cm_h_vec_2,
                cm_h_vec_3,
                cm_g,
                omega / z,
                y,
                y_1,
                y_2,
                z
            )
            .unwrap(),
        );
        let rand_xi_2 = hash_to_field::<E::Fr>(
            to_bytes!(
                x_vec,
                vk.cm_u_vec,
                vk.cm_w_vec,
                vk.cm_v_vec,
                vk.cm_y_vec,
                cm_u_vec_1,
                cm_s_vec,
                cm_h_vec,
                cm_r_vec_tilde,
                cm_t_vec_1,
                cm_h_vec_2,
                cm_h_vec_3,
                cm_g,
                omega / z,
                y,
                y_1,
                y_2,
                z
            )
            .unwrap(),
        );
        let zz = z;
        let z = omega / z;
        let f_commitments = vec![cm_h_vec, cm_u_vec_1, cm_r_vec_tilde];
        let g_commitments = vec![cm_g];
        let f_values = vec![y, y_1, y_2];
        let g_values = vec![E::Fr::zero()];

        if KZG10::<E, DensePoly<E::Fr>>::batch_check(
            &vk.kzg_vk,
            &f_commitments,
            &g_commitments,
            &z,
            &zz,
            &rand_xi,
            &rand_xi_2,
            &f_values,
            &g_values,
            &proof.W,
            &proof.W_1,
            rng,
        )? {
            Ok(())
        } else {
            Err(Error::VerificationFail)
        }
    }
}

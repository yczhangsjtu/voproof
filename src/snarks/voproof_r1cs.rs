///! This file is generated by https://github.com/yczhangsjtu/voproof-scripts/main.py
use super::*;

#[derive(Clone)]
pub struct R1CSProverKey<E: PairingEngine> {
  pub verifier_key: R1CSVerifierKey<E>,
  pub powers: Vec<E::G1Affine>,
  pub max_degree: u64,
  pub cap_m_mat: (Vec<u64>, Vec<u64>, Vec<E::Fr>),
  pub u_vec: Vec<E::Fr>,
  pub w_vec: Vec<E::Fr>,
  pub v_vec: Vec<E::Fr>,
  pub y_vec: Vec<E::Fr>,
}

#[derive(Clone)]
pub struct R1CSVerifierKey<E: PairingEngine> {
  pub cm_u_vec: Commitment<E>,
  pub cm_w_vec: Commitment<E>,
  pub cm_v_vec: Commitment<E>,
  pub cm_y_vec: Commitment<E>,
  pub kzg_vk: VerifierKey<E>,
  pub size: R1CSSize,
  pub degree_bound: u64,
}

#[derive(Clone)]
pub struct R1CSProof<E: PairingEngine> {
  pub cm_y_vec_1: Commitment<E>,
  pub cm_w_vec: Commitment<E>,
  pub cm_s_vec: Commitment<E>,
  pub cm_h_vec: Commitment<E>,
  pub cm_t_vec: Commitment<E>,
  pub cm_h_vec_2: Commitment<E>,
  pub cm_h_vec_3: Commitment<E>,
  pub y: E::Fr,
  pub cap_w: KZGProof<E>,
  pub cap_w_1: KZGProof<E>,
}

pub struct VOProofR1CS {}

impl<E: PairingEngine> SNARKProverKey<E> for R1CSProverKey<E> {}

impl<E: PairingEngine> SNARKVerifierKey<E> for R1CSVerifierKey<E> {}

impl<E: PairingEngine> SNARKProof<E> for R1CSProof<E> {}

impl VOProofR1CS {
  pub fn get_max_degree(size: R1CSSize) -> usize {
    (2 * (size.nrows as i64)
      + (size.ncols as i64)
      + (size.adensity as i64)
      + (size.bdensity as i64)
      + (size.cdensity as i64)) as usize
  }
}

impl<E: PairingEngine> SNARK<E> for VOProofR1CS {
  type Size = R1CSSize;
  type CS = R1CS<E::Fr>;
  type PK = R1CSProverKey<E>;
  type VK = R1CSVerifierKey<E>;
  type Ins = R1CSInstance<E::Fr>;
  type Wit = R1CSWitness<E::Fr>;
  type Pf = R1CSProof<E>;

  fn setup(size: usize) -> Result<UniversalParams<E>, Error> {
    let rng = &mut test_rng();
    KZG10::<E, DensePoly<E::Fr>>::setup(size, rng)
  }

  fn index(
    pp: &UniversalParams<E>,
    cs: &R1CS<E::Fr>,
  ) -> Result<(R1CSProverKey<E>, R1CSVerifierKey<E>), Error> {
    let max_degree = Self::get_max_degree(cs.get_size());
    let cap_d = pp.powers_of_g.len();
    assert!(cap_d > max_degree);

    let powers_of_g = pp.powers_of_g[..].to_vec();
    let size = cs.get_size();
    init_size!(cap_h, nrows, size);
    init_size!(cap_s_a, adensity, size);
    init_size!(cap_s_b, bdensity, size);
    init_size!(cap_s_c, cdensity, size);
    concat_matrix_vertically!(
      cap_m_mat, cap_h, cs.arows, cs.crows, cs.brows, cs.acols, cs.ccols, cs.bcols, cs.avals,
      cs.cvals, cs.bvals
    );
    define_generator!(gamma, E);
    define_matrix_vectors!(u_vec, w_vec, v_vec, cap_m_mat, gamma);
    define_hadamard_vector!(y_vec, u_vec, w_vec);
    define_commit_vector!(cm_u_vec, u_vec, powers_of_g, cap_s_a + cap_s_b + cap_s_c);
    define_commit_vector!(cm_w_vec, w_vec, powers_of_g, cap_s_a + cap_s_b + cap_s_c);
    define_commit_vector!(cm_v_vec, v_vec, powers_of_g, cap_s_a + cap_s_b + cap_s_c);
    define_commit_vector!(cm_y_vec, y_vec, powers_of_g, cap_s_a + cap_s_b + cap_s_c);

    let verifier_key = R1CSVerifierKey::<E> {
      cm_u_vec: cm_u_vec,
      cm_w_vec: cm_w_vec,
      cm_v_vec: cm_v_vec,
      cm_y_vec: cm_y_vec,
      kzg_vk: VerifierKey {
        g: pp.powers_of_g[0],
        h: pp.h,
        beta_h: pp.beta_h,
        prepared_h: pp.prepared_h.clone(),
        prepared_beta_h: pp.prepared_beta_h.clone(),
      },
      size,
      degree_bound: cap_d as u64,
    };
    Ok((
      R1CSProverKey::<E> {
        verifier_key: verifier_key.clone(),
        powers: powers_of_g,
        max_degree: max_degree as u64,
        cap_m_mat: cap_m_mat,
        u_vec: u_vec,
        w_vec: w_vec,
        v_vec: v_vec,
        y_vec: y_vec,
      },
      verifier_key,
    ))
  }
  fn prove(pk: &Self::PK, x: &Self::Ins, w: &Self::Wit) -> Result<Self::Pf, Error> {
    let size = pk.verifier_key.size.clone();
    let vk = pk.verifier_key.clone();
    let cap_d = pk.verifier_key.degree_bound as i64;
    let rng = &mut test_rng();
    sample_randomizers!(rng, delta_vec, 1, delta_vec_1, 1, delta_vec_2, 1);
    define_vec!(x_vec, x.instance.clone());
    define_vec!(w_vec, w.witness.clone());
    init_size!(cap_h, nrows, size);
    init_size!(cap_k, ncols, size);
    init_size!(cap_s_a, adensity, size);
    init_size!(cap_s_b, bdensity, size);
    init_size!(cap_s_c, cdensity, size);
    init_size!(ell, input_size, size);
    define!(n, cap_k + cap_s_a + cap_s_b + cap_s_c);
    define_sparse_mvp_vector!(
      y_vec_1,
      pk.cap_m_mat,
      concat_and_one!(x_vec, w_vec),
      3 * cap_h,
      cap_k
    );
    redefine_zero_pad_concat_vector!(y_vec_1, n, delta_vec);
    define_commit_vector!(cm_y_vec_1, y_vec_1, pk.powers, n + 1);
    redefine_zero_pad_concat_vector!(w_vec, n, delta_vec_1);
    define_commit_vector!(cm_w_vec, w_vec, pk.powers, n + 1);
    define!(ell_1, cap_s_a + cap_s_b + cap_s_c);
    define_generator!(gamma, E);
    get_randomness_from_hash!(
      mu,
      one!(),
      x_vec,
      pk.verifier_key.cm_u_vec,
      pk.verifier_key.cm_w_vec,
      pk.verifier_key.cm_v_vec,
      pk.verifier_key.cm_y_vec,
      cm_y_vec_1,
      cm_w_vec
    );
    define_expression_vector_inverse!(
      r_vec,
      i,
      minus!(mu, power_vector_index!(gamma, 3 * cap_h, i)),
      3 * cap_h
    );
    define_left_sparse_mvp_vector!(c_vec, pk.cap_m_mat, r_vec, 3 * cap_h, cap_k);
    define_concat_neg_vector!(s_vec, r_vec, c_vec);
    define_commit_vector!(cm_s_vec, s_vec, pk.powers, 3 * cap_h + cap_k);
    get_randomness_from_hash!(
      nu,
      one!(),
      x_vec,
      pk.verifier_key.cm_u_vec,
      pk.verifier_key.cm_w_vec,
      pk.verifier_key.cm_v_vec,
      pk.verifier_key.cm_y_vec,
      cm_y_vec_1,
      cm_w_vec,
      cm_s_vec
    );
    define_expression_vector_inverse!(
      rnu_vec,
      i,
      minus!(nu, power_vector_index!(gamma, cap_k, i)),
      cap_k
    );
    define_concat_uwinverse_vector!(h_vec, rnu_vec, mu, pk.u_vec, nu, pk.w_vec);
    define_commit_vector!(cm_h_vec, h_vec, pk.powers, cap_k + ell_1);
    define!(maxshift, 2 * cap_h);
    get_randomness_from_hash!(
      alpha,
      one!(),
      x_vec,
      pk.verifier_key.cm_u_vec,
      pk.verifier_key.cm_w_vec,
      pk.verifier_key.cm_v_vec,
      pk.verifier_key.cm_y_vec,
      cm_y_vec_1,
      cm_w_vec,
      cm_s_vec,
      cm_h_vec
    );
    define_vec!(
      t_vec,
      vector_concat!(
        delta_vec_2,
        expression_vector!(
          i,
          vector_index!(y_vec_1, minus_i64!(i + n, 1))
            * vector_index!(y_vec_1, minus_i64!(i + n, 2 * cap_h + 1))
            - range_index!(1, cap_h, minus_i64!(i + n, 2 * cap_h + 1))
              * vector_index!(y_vec_1, minus_i64!(i + n, cap_h + 1)),
          maxshift + 2
        )
      )
    );
    define_commit_vector!(cm_t_vec, t_vec, pk.powers, maxshift + 2);
    get_randomness_from_hash!(
      omega,
      one!(),
      x_vec,
      pk.verifier_key.cm_u_vec,
      pk.verifier_key.cm_w_vec,
      pk.verifier_key.cm_v_vec,
      pk.verifier_key.cm_y_vec,
      cm_y_vec_1,
      cm_w_vec,
      cm_s_vec,
      cm_h_vec,
      cm_t_vec
    );
    define!(c, omega.inverse().unwrap());
    define_vector_domain_evaluations_dict!(_y_vec_1_left_eval_dict, _y_vec_1_right_eval_dict);
    define_vector_poly_mul_shift!(
      v_vec_1,
      y_vec_1,
      y_vec_1,
      omega,
      shiftlength,
      _y_vec_1_left_eval_dict,
      _y_vec_1_right_eval_dict
    );
    define_vector_power_mul!(v_vec_2, y_vec_1, c, cap_h);
    define_vector_power_mul!(v_vec_3, t_vec, c, 2 * cap_h + 1);
    define!(c_1, -power(omega, 3 * cap_h - 1));
    define!(
      c_2,
      -power(omega, 2 * cap_h + cap_k + cap_s_a + cap_s_b + cap_s_c)
    );
    define_expression_vector!(
      h_vec_2,
      i,
      c_1 * vector_index!(v_vec_2, minus_i64!(i - maxshift - n, 2 - 2 * cap_h))
        + c_2 * vector_index!(v_vec_3, minus_i64!(i - maxshift - n, -2 * cap_h))
        + vector_index!(
          v_vec_1,
          minus_i64!(i - maxshift - n, 2 * cap_h - shiftlength + 1)
        ),
      maxshift + n
    );
    define_expression_vector!(
      h_vec_3,
      i,
      c_1 * vector_index!(v_vec_2, minus_i64!(i + 1, 2 - 2 * cap_h))
        + c_2 * vector_index!(v_vec_3, minus_i64!(i + 1, -2 * cap_h))
        + vector_index!(v_vec_1, minus_i64!(i + 1, 2 * cap_h - shiftlength + 1)),
      maxshift + n
    );
    define_commit_vector!(cm_h_vec_2, h_vec_2, pk.powers, cap_d);
    define_commit_vector!(cm_h_vec_3, h_vec_3, pk.powers, maxshift + n);
    get_randomness_from_hash!(
      z,
      one!(),
      x_vec,
      pk.verifier_key.cm_u_vec,
      pk.verifier_key.cm_w_vec,
      pk.verifier_key.cm_v_vec,
      pk.verifier_key.cm_y_vec,
      cm_y_vec_1,
      cm_w_vec,
      cm_s_vec,
      cm_h_vec,
      cm_t_vec,
      cm_h_vec_2,
      cm_h_vec_3
    );
    define_eval_vector_expression!(y, omega / z, i, vector_index!(y_vec_1, i), n + 1);
    define!(
      c_3,
      (y * power(z, 2 * cap_h) * (omega - one!() * z)
        + power(z, cap_h + 1) * power(omega / z, 2 * cap_h) * (one!() - power(omega / z, cap_h)))
        / (omega - one!() * z)
    );
    define!(
      c_4,
      power(z, n)
        * power(omega / z, cap_k + cap_s_a + cap_s_b + cap_s_c)
        * (one!() - power(omega / z, 2 * cap_h + 1))
        / (omega - one!() * z)
    );
    define!(c_5, -power(z, -cap_d));
    define!(c_6, -z);
    define_vec_mut!(
      g_vec,
      expression_vector!(
        i,
        linear_combination_base_zero!(
          c_3,
          vector_index!(y_vec_1, i),
          c_4,
          vector_index!(t_vec, i),
          c_5,
          vector_index!(h_vec_2, -cap_d + i + maxshift + n),
          c_6,
          vector_index!(h_vec_3, i)
        ),
        cap_d
      )
    );
    define_commitment_linear_combination_no_one!(
      cm_g, cm_y_vec_1, c_3, cm_t_vec, c_4, cm_h_vec_2, c_5, cm_h_vec_3, c_6
    );
    define_poly_from_vec!(y_vec_1_poly, y_vec_1);
    define_poly_from_vec!(g_poly, g_vec);
    check_poly_eval!(g_poly, z, zero!(), "g does not evaluate to 0 at z");
    define!(fs, vec!(y_vec_1_poly));
    define!(gs, vec!(g_poly));
    get_randomness_from_hash!(
      rand_xi,
      one!(),
      x_vec,
      vk.cm_u_vec,
      vk.cm_w_vec,
      vk.cm_v_vec,
      vk.cm_y_vec,
      cm_y_vec_1,
      cm_w_vec,
      cm_s_vec,
      cm_h_vec,
      cm_t_vec,
      cm_h_vec_2,
      cm_h_vec_3,
      cm_g,
      omega / z,
      y,
      z
    );
    get_randomness_from_hash!(
      rand_xi_2,
      scalar_to_field!(2),
      x_vec,
      vk.cm_u_vec,
      vk.cm_w_vec,
      vk.cm_v_vec,
      vk.cm_y_vec,
      cm_y_vec_1,
      cm_w_vec,
      cm_s_vec,
      cm_h_vec,
      cm_t_vec,
      cm_h_vec_2,
      cm_h_vec_3,
      cm_g,
      omega / z,
      y,
      z
    );
    define!(z1, omega / z);
    define!(z2, z);

    let (cap_w, cap_w_1) = KZG10::batch_open(&pk.powers, &fs, &gs, &z1, &z2, &rand_xi, &rand_xi_2)?;
    Ok(R1CSProof::<E> {
      cm_y_vec_1: cm_y_vec_1,
      cm_w_vec: cm_w_vec,
      cm_s_vec: cm_s_vec,
      cm_h_vec: cm_h_vec,
      cm_t_vec: cm_t_vec,
      cm_h_vec_2: cm_h_vec_2,
      cm_h_vec_3: cm_h_vec_3,
      y: y,
      cap_w: cap_w,
      cap_w_1: cap_w_1,
    })
  }
  fn verify(vk: &Self::VK, x: &Self::Ins, proof: &Self::Pf) -> Result<(), Error> {
    let size = vk.size.clone();
    let cap_d = vk.degree_bound as i64;
    let rng = &mut test_rng();
    let cm_y_vec_1 = proof.cm_y_vec_1;
    let cm_w_vec = proof.cm_w_vec;
    let cm_s_vec = proof.cm_s_vec;
    let cm_h_vec = proof.cm_h_vec;
    let cm_t_vec = proof.cm_t_vec;
    let cm_h_vec_2 = proof.cm_h_vec_2;
    let cm_h_vec_3 = proof.cm_h_vec_3;
    let y = proof.y;
    let cap_w = proof.cap_w;
    let cap_w_1 = proof.cap_w_1;
    define_vec!(x_vec, x.instance.clone());
    init_size!(cap_h, nrows, size);
    init_size!(cap_k, ncols, size);
    init_size!(cap_s_a, adensity, size);
    init_size!(cap_s_b, bdensity, size);
    init_size!(cap_s_c, cdensity, size);
    init_size!(ell, input_size, size);
    define!(n, cap_k + cap_s_a + cap_s_b + cap_s_c);
    define!(ell_1, cap_s_a + cap_s_b + cap_s_c);
    define_generator!(gamma, E);
    get_randomness_from_hash!(
      mu,
      one!(),
      x_vec,
      vk.cm_u_vec,
      vk.cm_w_vec,
      vk.cm_v_vec,
      vk.cm_y_vec,
      cm_y_vec_1,
      cm_w_vec
    );
    get_randomness_from_hash!(
      nu,
      one!(),
      x_vec,
      vk.cm_u_vec,
      vk.cm_w_vec,
      vk.cm_v_vec,
      vk.cm_y_vec,
      cm_y_vec_1,
      cm_w_vec,
      cm_s_vec
    );
    get_randomness_from_hash!(
      alpha,
      one!(),
      x_vec,
      vk.cm_u_vec,
      vk.cm_w_vec,
      vk.cm_v_vec,
      vk.cm_y_vec,
      cm_y_vec_1,
      cm_w_vec,
      cm_s_vec,
      cm_h_vec
    );
    get_randomness_from_hash!(
      omega,
      one!(),
      x_vec,
      vk.cm_u_vec,
      vk.cm_w_vec,
      vk.cm_v_vec,
      vk.cm_y_vec,
      cm_y_vec_1,
      cm_w_vec,
      cm_s_vec,
      cm_h_vec,
      cm_t_vec
    );
    get_randomness_from_hash!(
      z,
      one!(),
      x_vec,
      vk.cm_u_vec,
      vk.cm_w_vec,
      vk.cm_v_vec,
      vk.cm_y_vec,
      cm_y_vec_1,
      cm_w_vec,
      cm_s_vec,
      cm_h_vec,
      cm_t_vec,
      cm_h_vec_2,
      cm_h_vec_3
    );
    define!(
      c_3,
      (y * power(z, 2 * cap_h) * (omega - one!() * z)
        + power(z, cap_h + 1) * power(omega / z, 2 * cap_h) * (one!() - power(omega / z, cap_h)))
        / (omega - one!() * z)
    );
    define!(
      c_4,
      power(z, n)
        * power(omega / z, cap_k + cap_s_a + cap_s_b + cap_s_c)
        * (one!() - power(omega / z, 2 * cap_h + 1))
        / (omega - one!() * z)
    );
    define!(c_5, -power(z, -cap_d));
    define!(c_6, -z);
    define_commitment_linear_combination_no_one!(
      cm_g, cm_y_vec_1, c_3, cm_t_vec, c_4, cm_h_vec_2, c_5, cm_h_vec_3, c_6
    );
    define!(z1, omega / z);
    define!(z2, z);
    get_randomness_from_hash!(
      rand_xi,
      one!(),
      x_vec,
      vk.cm_u_vec,
      vk.cm_w_vec,
      vk.cm_v_vec,
      vk.cm_y_vec,
      cm_y_vec_1,
      cm_w_vec,
      cm_s_vec,
      cm_h_vec,
      cm_t_vec,
      cm_h_vec_2,
      cm_h_vec_3,
      cm_g,
      omega / z,
      y,
      z
    );
    get_randomness_from_hash!(
      rand_xi_2,
      scalar_to_field!(2),
      x_vec,
      vk.cm_u_vec,
      vk.cm_w_vec,
      vk.cm_v_vec,
      vk.cm_y_vec,
      cm_y_vec_1,
      cm_w_vec,
      cm_s_vec,
      cm_h_vec,
      cm_t_vec,
      cm_h_vec_2,
      cm_h_vec_3,
      cm_g,
      omega / z,
      y,
      z
    );
    define!(f_commitments, vec!(cm_y_vec_1));
    define!(g_commitments, vec!(cm_g));
    define!(f_values, vec!(y));
    define!(g_values, vec!(zero!()));

    if KZG10::<E, DensePoly<E::Fr>>::batch_check(
      &vk.kzg_vk,
      &f_commitments,
      &g_commitments,
      &z1,
      &z2,
      &rand_xi,
      &rand_xi_2,
      &f_values,
      &g_values,
      &cap_w,
      &cap_w_1,
      rng,
    )? {
      Ok(())
    } else {
      Err(Error::VerificationFail)
    }
  }
}
